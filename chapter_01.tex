% chapter_01.tex - Spec Coding 基础
\small

\chapter{Spec Coding 基础}

\section{Spec Coding 与 Vibe Coding：工程范式的演进}

\subsection{核心概念}

Vibe coding 是「生成方式」，Spec coding 是「约束方式」；它们不是对立关系，而是同一条工程成熟度曲线上的不同阶段。Vibe coding 解决的是：怎么快；Spec coding 解决的是：怎么不出事。

\subsubsection{Vibe Coding 本质}

Vibe coding $\neq$ 不写规范。它的本质是：在不完全明确需求的情况下，通过人与模型的「感觉对齐」，快速逼近可用实现。

典型特征：用自然语言、模糊、迭代、即时反馈、「差不多对了，再改一点」。强烈依赖模型能力和开发者审美/判断力。

常见场景：原型验证、Hackathon、个人项目、探索性功能、UI/UX 草图。

\subsubsection{Spec Coding 本质}

Spec coding 不是传统意义上的「写文档」，而是：把「你脑子里的隐性约束」显式化，强迫模型在一个受控空间里生成代码。

核心特征：明确输入/输出、明确不变量（invariants）、明确边界条件、明确失败方式。

常见场景：核心业务逻辑、金融/医疗/安全相关代码、多人协作、长期维护项目、自动化测试/CI。

\subsubsection{阶段切换关系}

成熟团队的真实流程是：Vibe $\to$ 半 Spec $\to$ 强 Spec。

\textbf{Vibe 阶段}：探索问题空间。快速、混乱、但便宜。

\textbf{半 Spec 阶段}：固化直觉。把成功的 vibe 对话提炼成接口、状态机、约束条件，开始补测试。

\textbf{Spec 阶段}：规模化与防退化。明确 spec 让模型可复现、可回滚、可替换。此时 vibe 是负资产。

\subsubsection{为什么单一模式不可持续}

「只有 Vibe coding」的问题：一个人时很好用，三个人开始互相骂，六个月后没人敢动代码，模型升级后行为漂移。原因只有一个：Vibe 没法被版本控制。

「只有 Spec coding」的问题：需求还没想清楚就强行写 spec，导致 spec 本身反复重写，模型生成「合规但没用」的代码。Spec 是收敛工具，不是探索工具。

\subsubsection{实用判断标准}

问自己一句话：「如果明天模型换一家，我现在写的东西还能用吗？」
\begin{itemize}
    \item 不能 $\to$ 你还在 vibe
    \item 能 $\to$ 你已经 spec 化了
\end{itemize}

\subsubsection{未来趋势}

到 2026 年，主流工程范式会是：Vibe 用来找方向，Spec 用来保成果。好的工程师将具备一种新能力：把 vibe 转译成 spec 的能力。这会比「会不会写 prompt」重要得多。


\section{Spec 的三种形态}

\subsection{形态分类}

\textbf{工作态 spec}（不进 git）：
\begin{itemize}
  \item 本地笔记、对话、临时 markdown
  \item 用于思考、对齐、驱动实现
  \item 不要求持久化，squash 后自然消失
\end{itemize}

\textbf{协作态 spec}（进 git，有生命周期）：
\begin{itemize}
  \item docs/wip/、specs/、design/ 目录
  \item PR 中 review，merge 时决定是否留下
\end{itemize}

\textbf{契约态 spec}（必须长期存在）：
\begin{itemize}
  \item docs/adr/、docs/api/、README
  \item 必须进 main，长期维护，是团队记忆
\end{itemize}

\subsection{判断准则}

"两问法"决定 spec 去向：
\begin{enumerate}
  \item 这个 spec 对"feature 完成后"还有用吗？
  \item 如果我明天请假，别人需要它吗？
\end{enumerate}

\begin{itemize}
  \item 两个都否 $\to$ 不 commit / 删除
  \item 任一是 $\to$ commit 到 main（或 issue/PR）
\end{itemize}

\section{工程工具目录辨析}

\subsection{常见工具目录}

\textbf{.idea/}：JetBrains 系列 IDE 的工程结构、运行配置、个人快捷键。IDE 私有、高度个人化。通常不 commit、不能当 spec/文档。

\textbf{.vscode/}：VS Code 的 settings.json、launch.json、extensions 推荐。个人设置不 commit，团队约定（少量）可 commit（例如 formatter）。

\textbf{.cursor/}：Cursor AI 编辑器的 AI 行为配置、prompt 模板、会话状态。本质和 .specify/ 一样是 AI 工具的私有工作区。不应该被当作工程事实。

\textbf{.venv/}：Python 虚拟环境、第三方库、解释器副本。本地运行环境、可再生。永远不 commit、用 requirements.txt/pyproject.toml 描述即可。

共同点：可再生、不可审计、不应成为「项目真相」。

\subsection{判断公式}

以后看到任何目录/文件，问一句：「如果我换 IDE/换 AI/换机器，这个东西还应该存在吗？」
\begin{itemize}
    \item 是 $\to$ 应该进 repo（docs/code/adr）
    \item 否 $\to$ 工具状态（ignore）
\end{itemize}

\section{ADR（Architecture Decision Record）}

ADR = 用来记录「为什么我们在架构上做了这个决定」的文档。它解决的不是「怎么写代码」，而是：我们当时在多个方案中为什么选了这一种、哪些选择是被明确否掉的、这个决定对未来有什么约束。

\subsection{ADR 的内容}

一个典型 ADR 会回答 4 件事：
\begin{itemize}
    \item \textbf{Context}：发生了什么问题？为什么要做决定？
    \item \textbf{Decision}：我们选了什么方案？
    \item \textbf{Alternatives}：还考虑过哪些方案？为什么没选？
    \item \textbf{Consequences}：这个决定带来的好处和代价是什么？
\end{itemize}

\subsection{ADR 与其他文档的区别}

\begin{tabular}{ll}
文档 & 关注点 \\
\hline
README & 项目是什么，怎么用 \\
spec & 功能行为是什么 \\
design doc & 怎么实现 \\
ADR & 为什么这么设计 \\
\end{tabular}

ADR 是「不可见的工程记忆」。在 AI 时代更重要，因为：AI 看不到当初的讨论、AI 容易重提已被否定的方案、人类也会忘。

\subsection{ADR 的优先级}

ADR 的优先级是：对「是什么」的解释权 > 对「为什么」的解释权。README 可以说「我们使用 PostgreSQL」，但不能说「因为 XYZ，所以否掉了 DynamoDB」。这种理由属于 ADR。

\vspace{1em}
\normalsize
