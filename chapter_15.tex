% chapter_15.tex - Spec-Driven Git 工作流实战
\small

\chapter{Spec-Driven Git 工作流实战}

\section{Pull Request 的本质与定位}

\subsection{PR 的定义}

Pull Request = 代码合并请求。在 Git 工作流中，PR 是将 feature 分支的变更合并到目标分支（通常是 main）的正式机制。PR 不仅包含代码差异（diff），还关联了上下文信息：spec、plan、tasks、commit 历史。

\subsection{PR 在 Spec-Driven 中的角色}

在 spec-driven 开发中，PR 承载三重功能：

\textbf{(1) 代码审查载体}：Review 者通过 PR 查看 spec 定义与实际实现的对应关系，验证是否按 spec 执行。

\textbf{(2) 决策边界}：PR 是"是否接受此 feature 进入主线"的人类决策点。AI 可以执行 implement，但无法决定"这段代码是否值得进 main"。

\textbf{(3) 历史记录单元}：PR 合并后，其 title、description、讨论内容成为永久可追溯的工程文档。

\subsection{PR 与 Spec 的关系}

Spec 文件（.specify/specs/XXX/spec.md）与代码在同一 feature 分支中创建和提交。PR 打开时，spec 已作为 commit 的一部分存在。Review 者在 PR 中同时看到：spec 内容（为什么这么做）+ 代码变更（怎么做的）+ 测试结果（是否有效）。

\section{Spec-Driven 工作流的四个阶段}

\subsection{阶段 1：Spec / Plan / Tasks（决策阶段）}

位置：feat/* 分支

操作：定义需求、约束实现路径、拆解任务

状态：可反复修改、不产生代码、仅存在规划文档

\subsection{阶段 2：/speckit.implement（执行阶段）}

位置：同一 feat/* 分支

AI 被允许：按 tasks 写代码、创建/修改文件

AI \textbf{不被允许}：commit、merge、push

结果：代码仅存在于 working tree，未进入 Git 历史

\subsection{阶段 3：人类 Review（控制阶段）}

操作：执行 \texttt{git diff} 查看 spec、plan、tasks 与 code diff

决策：接受 / 拒绝 / 修改 spec 后重新 implement

此阶段是 spec-driven 的核心安全闸门。

\subsection{阶段 4：Merge（生效阶段）}

操作：手动 \texttt{git merge} 或点击 PR merge 按钮

这是唯一影响 main 分支的时刻，必须由人类触发。

\section{关键设计原则：执行与生效的分离}

\subsection{为什么 implement 不自动 commit？}

Commit 是"责任边界"，不能由 AI 自动跨越。原因：

\textbf{(1)} Commit 代表对历史节点的认可：哪些文件算完成、commit message 怎么写、是一个 commit 还是多个——这些都是工程判断，非执行判断。

\textbf{(2)} Commit 是 review 之后的动作，非 implement 的一部分。正确顺序：implement $\rightarrow$ review $\rightarrow$ commit。若 implement 自动 commit，review 变成事后补救，历史会被污染。

\subsection{为什么 spec 同意不自动 merge？}

AI 可以执行，但不能决定"什么时候对世界负责"。在工程中：commit = 对历史负责、merge = 对主线负责、release = 对用户负责。这些责任点不能自动化。

用户同意 spec 的真实含义是："我授权 AI 按此计划尝试实现，但结果是否可接受，仍由我决定。"而非："我同意这段代码直接进 main。"

\section{Commit 策略：从防丢存档到决策节点}

\subsection{Spec-Driven 下 Commit 的角色变化}

传统 vibe coding：高频、碎片化 commit，作用是"防丢代码"。

Spec-driven：低频、语义化 commit，作用是"标记决策节点"。

\subsection{Feat 分支仍需人工 Commit}

原因：(1) commit 是 review 的最小单位；(2) commit 控制"回滚粒度"；(3) merge 的前提是 commit（merge 的对象是 commit，非工作区）。

\subsection{推荐 Commit 原则}

\textbf{1} 决策变成现实 $\rightarrow$ commit

\textbf{2} 一个 commit = 一个"可解释状态"

\textbf{3} commit 不是越多越好，而是越"语义完整"越好

\textbf{4} 判断口诀："如果现在让我向别人解释当前状态，我是否有一句话能概括？"有则 commit，无则等待。

\subsection{健康的 Commit 节奏示例}

\begin{verbatim}
feat/todo-cli 分支：

commit 1: docs(todo): finalize spec and plan
commit 2: feat(todo): implement todo CLI
\end{verbatim}

spec/plan 单独 commit，implement 是一个或少量 commit，中间不频繁碎 commit。

\section{.specify/ 目录的 Git 生命周期}

\subsection{核心原则}

.specify/ 与代码在 Git 里是同一等级。Git 眼里只有"哪些文件在 commit 里"，对 .specify/specs/001-xxx/spec.md 与 src/foo.ts 一视同仁。

\subsection{Spec 进入 Main 的时机}

.specify/ 并非"自动等到 merge 才进入 main"，而是：始终存在于 feat 分支；是否进入 main，完全取决于 merge 时是否保留它。没有任何"延迟进入 main"的特殊机制。

\subsection{推荐模式：Spec 跟 Feature 一起 Merge}

\begin{verbatim}
feat/xxx branch:
  - commit A: docs: add spec/plan/tasks
  - commit B: feat: implement xxx

merge → main

结果：main 包含代码 + .specify/specs/001-xxx/
\end{verbatim}

这是 spec-driven 的"完整形态"：feature 的"做什么"和"为什么"都被永久记录在 main 历史中。

\subsection{其他模式}

\textbf{Squash merge}：.specify/ 是否进入 main 取决于 squash 的 commit 里是否包含它。若 squash 时只选代码或手动删 .specify/，则不会进 main——这是人的选择，非工具规则。

\textbf{删除 spec（不推荐）}：有些团队在 feature 完成后删除 .specify/ 再 merge。技术上合法，但工程上是损失：删除了决策依据、设计上下文、未来重构的参考。

\subsection{分支删除与文件保留}

\begin{verbatim}
feat branch: .specify/ + src/

↓ merge

main: .specify/ + src/

↓ delete feat branch

main: .specify/ + src/  （仍存在）
\end{verbatim}

删除分支 $\neq$ 删除文件。只要文件被 commit 且 commit 被 merge，文件就进入了 main。

\section{Squash：选择性公开历史}

\subsection{定义与直觉}

Squash = 把多个 commit"压扁"为一个 commit。将 commit 链从 A-B-C-D-E 压缩为单个 commit X，历史被"整理过"，只留下一个"对外可读"的结果。

\subsection{解决的问题}

不 squash 时，main 分支历史充满"fix typo"、"wip"等噪音。Squash 让 main 只保留"做了什么"而非"怎么折腾的"，是对主线历史可读性的优化手段。

\subsection{与 spec-driven 的关系}

在 spec-driven 中，squash 非常常见且推荐。因为 spec/plan 已记录过程，main 更适合只保留 spec 定义和最终实现。健康的结果是 main 中每个 commit 对应一个完整的 feature 意图。

\subsection{重要澄清}

squash ≠ 删除历史。原 commit 仍保留在 feat 分支和 reflog 中，只是不进入 main。这是"选择性公开历史"，而非抹除历史。

\subsection{何时不用 squash}

release/hotfix 分支需要精确 bisect 的历史时，每个 commit 都应是稳定点。

\subsection{判断口诀}

main 要不要看懂"你怎么一步步写的"？不需要 → squash；需要 → 不 squash。

\subsection{spec-driven 最佳实践}

在 feat/* 分支上随意 squash；PR merge 时 squash 整个 feature；不在 main 上做 rebase/squash。让 feature 内部历史自由，main 历史干净。

\subsection{本质}

squash 的本质：把"开发过程"留在 feature 分支，把"工程结果"放进 main。

\section{Squash 的作用范围}

\subsection{常见误解}

很多人以为 squash 只能压缩顶部一段 commit 链。这是错误印象。

\subsection{真实能力}

Git 的 squash 本质是合并多个 commit 的 diff。前提是：这些 commit 在同一条线性历史上；能明确指定"哪些 commit 参与合并"。Git 不要求它们在最顶部，但必须连续、可重写。

\subsection{为何造成误解}

99\% 的工具只暴露了"压缩顶部"的用法：PR 的"Squash and merge"默认压缩从分支起点到 HEAD；git rebase -i HEAD~5 只显示最近的 commit。

\subsection{实际能力}

你可以用 \texttt{git rebase -i <某个更早的 commit>} squash 任何一段连续提交，包括中间段或不包含 HEAD 的段。但这是历史重写，只能在自己的 feature 分支上进行。

\subsection{工程实践}

我们几乎"只在顶部 squash"是工程纪律，非技术限制：避免影响别人；PR 语义天然是"一段顶部历史"；认知负担最低。

\subsection{精确表述}

Squash 的限制不是"必须在顶部"，而是"必须是连续、可重写的一段历史"。

\section{Merge 后是否开新分支}

\subsection{结论}

feat 分支一旦 merge 到 main，其"使命"就结束。继续 spec-coding 新内容时，应从 main 再开新的 feat 分支。

\subsection{原因}

\textbf{原因 1：merge = 生命周期结束。} merge 声明"这个 feature 已完成并被主线接受"。继续在同一分支写新 spec 会让 PR、review、回滚边界模糊。

\textbf{原因 2：PR/spec 语义崩坏。} 已 merge 的 feat/xxx 上继续写新的 spec.md/tasks.md，会导致"这个分支代表哪个 feature"、"PR review 的 scope 是什么"等问题。

\textbf{原因 3：spec-driven 强依赖边界清晰。} spec-driven 中：一个 feature → 一组 spec/plan/tasks → 一次 implement → 一次 merge，形成闭环。

\subsection{标准流程}

\begin{verbatim}
# 1. 旧 feature 已 merge
git checkout main
git pull

# 2. 开新 feature
git checkout -b feat/user-auth

# 3. 新的 spec coding
.specify/specs/002-user-auth/
\end{verbatim}

\subsection{分支命名}

名称表达意图而非工具生成：feat2、feat/user-auth、feature/checkout、task/123-user-auth 均可。spec-kit 完全不关心 Git 分支名，只读取当前分支并写 spec 到 \texttt{.specify/specs/<some-id>/}。

\subsection{例外情况}

\textbf{例外 1：} merge 后立刻发现小 bug/typo。可用 \texttt{git checkout -b fix/todo-cli-typo} 或直接在 main hotfix（小项目/solo），但这已是维护而非 spec-coding。

\textbf{例外 2：} spec 尚未 merge，只是第一次 implement。若 spec/plan 已写但代码未 merge/PR 还在 review，不用开新分支。同一 feature 内可反复 spec → implement → 调整。只有真正 merge 后生命周期才结束。

\subsection{判断口诀}

"我要做的这件事，在 PR 描述里能不能用一句话和上一次区分开？"能 → 新分支；不能 → 同一 feature。

\subsection{spec-driven 对应关系}

spec 是 feature 的定义；merge 是 feature 的完成声明。所以：新 spec = 新 feature = 新 branch。这是 1:1:1 对应关系。

\section{分支命名与 spec-kit}

\subsection{分支名能否重复}

可以"再次使用同一个名字"，但不能"在同一时间重复存在"。Git 规则：同一仓库、同一时间点不能有两个同名分支。但旧分支删除后可再创建同名分支，Git 不会记得"之前用过这个名字"。

\subsection{工程实践}

通常不推荐复用完全相同的 feature 分支名，原因是 PR 历史混淆、日志不好读、人类记忆差。推荐做法：feat/todo-cli、feat/todo-cli-v2、feat/user-auth、feat/checkout-flow 或 feat/123-todo-cli。名字表达"意图"而非"工具生成"。

\subsection{spec-kit 的角色}

spec-kit 完全不关心 Git 分支名。它只读取当前 Git 分支，把 spec 写到 \texttt{.specify/specs/<some-id>/}，用 <some-id> 作为 feature 内部标识。这个 id 不是 Git 分支名，不要求一一对应，通常是递增数字 + slug。

\subsection{两套命名系统}

Git 分支名：人类协作用，不与 spec 目录强绑定。.specify/specs/<id>：spec 组织用。两者关系是弱关联、非强绑定、靠人理解。

\subsection{安全心法}

Git 分支名是"临时工作名"；spec 目录名是"长期设计档案号"。一个可以删，一个不该轻易删。

\section{Merge 历史形态}

\subsection{毛毛虫效应}

使用普通 merge（非 squash）时，merge 后通常不删除原 commit，整个历史看起来像一条"毛毛虫/树枝状"。这不是 Git 的必然结果，而是 merge 策略的选择。

\subsection{普通 merge}

执行 \texttt{git merge feat} 生成 merge commit。所有原 commit 保留，历史非线性。用 \texttt{git log --graph} 看像长着小脚的毛毛虫。Git 原则：历史默认不可丢失，删的是"指针"不是 commit。commit 只要被 merge 就永远存在于 main 历史。

\subsection{Squash merge}

多个 commit 的 diff 合并为一个新 commit X。原 commit 不进入 main，历史重新变直（linear history）。没有毛毛虫，像蚯蚓。

\subsection{Rebase + merge}

merge 前做 \texttt{git rebase main} 然后 fast-forward merge。历史线性，但 commit hash 已被改写。

\subsection{选择标准}

都不是好坏问题，是选择。保留毛毛虫（普通 merge）优点：保留完整开发过程、可精确 bisect，适合大型团队、release/hotfix 流程。消灭毛毛虫（squash/rebase）优点：main 历史干净、每个 commit 是完整语义单元，适合 spec-driven、PR-based workflow、feature=intent。

spec-driven 通常选 squash，因为 spec/plan 已记录过程，main 更像"产品演进日志"而非"开发录像"。

\subsection{判断口诀}

你希望 main 像"故事书"还是"监控录像"？故事书 → squash；监控录像 → 普通 merge。

\section{Merge 策略选择}

\subsection{常见度排序}

在现代 PR-based workflow 里：Squash merge 最常见；普通 merge（merge commit）次常见；Rebase merge（直接在 main 上 rebase）最少。尤其在 GitHub/GitLab + PR + spec-driven 场景。

\subsection{Squash 为主流的原因}

\textbf{原因 1：PR 语义 = "一个意图"。} PR 声明"我完成了一件事，请把它合进去"，squash merge 正好是"把这一件事变成 main 上的一个 commit"，两者 1:1 对齐。

\textbf{原因 2：现代 PR commit 粒度不干净。} PR 里经常是"fix typo、address review、oops forgot test、tweak"。不 squash 会让 main 被噪音 commit 淹没。

\textbf{原因 3：spec-driven 已保存过程。} spec-driven 中过程 = spec/plan/tasks，main 更像"结果日志"，squash 非常自然。

\subsection{普通 merge 的适用场景}

普通 merge 仍有价值，更适合：Linux kernel、编译器/基础设施项目、强依赖 git bisect、每个 commit 都被要求是"可运行状态"。这些项目里 commit 本身就是设计单元。

\subsection{Rebase 为何最少}

rebase = 历史重写 + 高认知成本。在 main 上 rebase 的问题：谁在什么时候改写了历史？多人同时操作易出事故；PR review 时 hash 会变。所以大多数团队禁止在 main 上 rebase，rebase 只允许在 feature 分支内。

\subsection{精确对比}

\begin{tabular}{|l|l|l|}
\hline
策略 & feature 内 commit & main 上 commit \\
\hline
普通 merge & ✅ 原样保留 & ✅ 原样保留 \\
squash merge & ✅ 保留在 feat & ❌ 不进入 main \\
rebase + FF & ✅ 改写后保留 & ✅ 线性进入 main \\
\hline
\end{tabular}

\subsection{spec-driven 推荐}

squash 满足 4 点：main 历史可读、feature 内部自由、PR review 聚焦、回滚语义清晰。而 spec/plan 本身就是"过程记录"。

\subsection{建议}

如果不确定用哪种，默认用 squash merge。等你明确知道"为什么不用 squash"时再换。

\section{Git Rebase 与 Spec-Driven 实践}

\subsection{Rebase 的本质与正确用法}

\subsubsection*{git pull 的分解}
\begin{verbatim}
git pull = git fetch + git merge
\end{verbatim}
执行 \texttt{git pull} 实际上是在 merge，不是 rebase。

\subsubsection*{正确的 rebase 同步姿势}
\begin{verbatim}
git fetch origin
git rebase origin/main
\end{verbatim}
或：
\begin{verbatim}
git pull --rebase
\end{verbatim}

\subsubsection*{Rebase 的真正本质}
Git rebase = 把"我这一串 commit" 从"旧的 base" 重新接到"新的 base"上。

\subsubsection*{原始状态}
\begin{verbatim}
main: A -> B -> C
    \
feat:    D -> E (你的提交)
\end{verbatim}

执行 \texttt{git rebase main} 后的结果：
\begin{verbatim}
main: A -> B -> C
    \
feat:    D' -> E'
\end{verbatim}
\begin{itemize}
\item 内容一样
\item commit hash 全变了
\item 历史变成线性的
\end{itemize}

\subsubsection*{stash 的作用}
stash 是"可选的前置操作"，不是 rebase 的一部分。如果工作区有未提交修改，Git 会拒绝 rebase，因此常见的流程是：
\begin{verbatim}
git stash
git rebase main
git stash pop
\end{verbatim}
这是为了让 rebase 能运行，不是 rebase 的定义。

\subsubsection*{Rebase 的正确表述}
"我在 feature 分支上，通过 rebase 把自己的提交，重新基于最新的 main 应用一遍，让历史看起来像是从最新 main 开始开发的。"

\subsubsection*{何时使用 Rebase}
\begin{itemize}
\item 只在你自己的 feature 分支上
\item 在提交还没被别人依赖时
\item 不要在 main / 已共享分支上 rebase
\end{itemize}

\subsubsection*{Spec-Driven 中的 Rebase}
\begin{itemize}
\item 常用于：PR 前整理历史、保持 feature 分支线性
\item 不用于：自动 merge 替代 review
\end{itemize}

\subsubsection*{关键认知}
rebase 的体感像"同步代码"，但本质是"重写你这段提交的历史位置"；stash 只是为了让它能发生，而不是 rebase 本身。

\section{Specify 与 Skills 的关系}

\subsection{Specify 已覆盖 Skills 的价值}

使用 specify（spec / plan / tasks）后，一般不需要额外写"零散的说明性 skills 文档"，但这不等于"什么都不用写了"。

\subsection{Specify 的职责}
specify 管的是"这个 feature 为什么存在、要做成什么样、怎么一步步实现"。

\subsection{Specify 不替代的内容}
\begin{itemize}
\item README（项目整体介绍）
\item 架构文档（长期存在的）
\item ADR（架构决策记录）
\item API 文档（对外契约）
\item 运维 / 部署文档
\end{itemize}

\subsection{Specify 替代的内容}
"为了完成某一个 feature，临时写的一堆解释性文字和 checklist。"

\subsection{使用 Specify 后的状态}
\textbf{不再做的事}：
\begin{itemize}
\item "这个 PR 做了什么"的长篇说明
\item "开发步骤"散落在 Issue / PR 里
\item 临时的 skills / notes 文档
\end{itemize}

\textbf{仍然会做的事}：
\begin{itemize}
\item 在 \texttt{.specify/specs/xxx/} 里写清楚 spec / plan / tasks
\item 在 PR 里链接这个 spec，一句话总结即可
\end{itemize}

\subsection{判断准则}
当想写一个"skills / 说明"时，问自己："这是为了完成'当前这个 feature'吗？"
\begin{itemize}
\item 是 -> 放进 spec
\item 不是（长期、全局、架构级）-> 单独文档
\end{itemize}

\subsection{定锚}
使用 specify 之后，不需要再额外写"为 feature 服务的 skills 文档"，因为 spec / plan / tasks 本身就是它们的结构化升级版；但它并不取代项目级、长期存在的文档。

\section{Sub-Agent 与工程流程}

\subsection{droid 与 Claude Code 的 sub-agent 机制}

\subparagraph{droid 对 sub-agent 的支持}

droid 本身不显式暴露 sub-agent 概念，但用户的使用方式本质上已经在"手动模拟 sub-agent"。在单上下文工作流中，用户通过明确指令（"现在只做 X"、"不要改别的"）实现受控的子任务执行，用完即丢。这在认知模型上就是 sub-agent，只是没有被工具层包装。droid 选择的是"人当 orchestrator，而不是系统当 orchestrator"，这对复杂工程反而更稳。

在 droid 单上下文、spec 驱动、人控节奏的工作方式中，sub-agent 是工具层优化，不是方法论升级，也不是必须品。

\textbf{核心原则：} sub-agent 的意义是减少上下文切换和重复解释，而不是替代判断或 spec。不用它不代表落后，理解它反而更不容易被营销带偏。

\subsection{Git 工作流：feat branch 与 squash merge}

\subsubsection{标准工程流}

手动 branch 一个 feat → implement → 测试没问题 → squash merge。这套流程本质上是"纯工程习惯驱动的 spec-coding"，完全正确，不依赖任何 skills/agent 魔法，是目前最稳、最抗 AI 演进变化的方式。这是标准工程流 + LLM 辅助，而不是"AI 驱动工程"。

\textbf{工程意义：}
\begin{itemize}
\item 变更是有边界的
\item 失败是可回滚的
\item 主分支永远是干净的
\end{itemize}

\subsubsection{为什么这套流程在不依赖 agent 时更重要}

当不用自动化 spec/agent 时：
\begin{itemize}
\item git 就是状态管理系统
\item branch 就是 agent 隔离
\item squash 就是 context 压缩
\end{itemize}

这是 Git 级别的"sub-agent 隔离"，比很多 multi-agent demo 更可靠。

\subsubsection{squash merge 的工程价值}

squash merge 把试错 prompt、调整、LLM 生成垃圾全部压扁，最终主分支只留下"spec → 实现成功"这一条事实。这非常符合 LLM 不可审计中间思考的现实。

对比 AI agent 流程（agent 自己开分支、自己 commit、人事后 review），feat branch + 人控 merge 在工程上反而更安全。

\textbf{核心原则：} "所有不确定性，都留在分支里；所有确定性，才进 main。"这条原则比任何 skills 都值钱。

spec-coding 不需要花哨工具；branch 是隔离，test 是验证，squash 是记忆压缩。

\section{Spec 的生命周期管理}

\subsection{spec 在 feat branch 与 main 中的差异}

在所述工作流中，spec 通常只存在于 feat branch 的工作上下文中，不一定、也不必须被 commit 到 main。但这需要精确前提。

\textbf{临时 spec 的本质：} 一次性工程决策说明，而不是 API 合同、架构规范、长期维护文档。这类 spec 用于：
\begin{itemize}
\item 思考
\item 对齐
\item 驱动实现
\end{itemize}

不要求持久化，squash 后自然消失。squash merge 的结果是 main 只保留"做成了什么"，而不保留"中间怎么想的"，这是非常成熟的工程选择。

\subsection{三种 spec 形态}

\textbf{① 工作态 spec（不进 git）：}
\begin{itemize}
\item 形态：本地笔记、Chat/LLM 对话、临时 markdown（不 add）、issue comment/PR description
\item 特点：不要求持久化，squash 后自然消失
\end{itemize}

\textbf{② 协作态 spec（进 git，但有生命周期）：}
\begin{itemize}
\item 形态：\texttt{docs/wip/feature-x.md}、\texttt{specs/feature-x.md}、\texttt{design/feature-x.md}
\item 做法：在 feat branch commit、PR 中 review、merge 时，要么一起 squash 进 main，要么在 merge 前删除。是否留下是显式决策。
\end{itemize}

\textbf{③ 契约态 spec（必须长期存在）：}
\begin{itemize}
\item 形态：\texttt{docs/adr/0007-auth-flow.md}、\texttt{docs/api/*.md}、README 更新
\item 特点：必须进 main，长期维护，是团队"记忆"
\end{itemize}

\subsection{spec 去留判断标准}

判断句："如果半年后我或别人看到 main，只看代码和测试，还需要知道这份 spec 吗？"

✅ 需要 → commit；❌ 不需要 → 不 commit。

\textbf{spec 必须进 main 的情况：}
\begin{itemize}
\item 跨 feature、影响未来决策
\item 对他人是约束
\item 需要被 review/回溯
\end{itemize}
例如：API 设计、数据模型约定、行为边界（edge cases）、业务规则。这时它不再是"临时 spec"，而是设计文档/contract，应该 commit 到 main（如 \texttt{docs/}、\texttt{adr/}）。

\textbf{spec 不需要进 main 的情况：}
\begin{itemize}
\item 只为这一次实现服务
\item 已经通过代码和测试体现
\item squash 后不再需要
\end{itemize}
留在 branch/对话/note 就好。

\subsection{未完成 feature 的 spec 处理}

对于未完成的 feature，spec \textbf{必须}存在于：
\begin{itemize}
\item PR 描述
\item issue
\item wip doc
\end{itemize}

而不是只存在于已 squash 掉的 branch，否则就是把项目状态藏进了历史里（反模式）。

\textbf{"两问法"决定 spec 去向：}
\begin{enumerate}
\item 这个 spec 对"feature 完成后"还有用吗？
\item 如果我明天请假，别人需要它吗？
\end{enumerate}
两个都否 → 不 commit/删除；任一为是 → commit 到 main（或 issue/PR）。

\subsection{spec 与 LLM-assisted coding 的关系}

LLM 的"中间 reasoning"不可审计，spec 里往往包含假设、试错、被推翻的方案。保留这些反而会污染长期认知。squash merge + 丢弃临时 spec，是在主动做"认知垃圾回收"。

临时 spec 是工作记忆，main 只保留长期记忆；squash merge 的意义不仅是压缩 commit，也是压缩思考噪音。

\section{Architecture Decision Record (ADR)}

\subsection{ADR 定义}

ADR = Architecture Decision Record，用来记录"为什么我们在架构上做了这个决定"的文档。它解决的不是"怎么写代码"，而是：
\begin{itemize}
\item 我们当时在多个方案中，为什么选了这一种
\item 哪些选择是被明确否掉的
\item 这个决定对未来有什么约束
\end{itemize}

\subsection{ADR 与其他文档的区别}

\begin{tabular}{ll}
\textbf{文档} & \textbf{关注点} \\
README & 项目是什么，怎么用 \\
spec & 功能行为是什么 \\
design doc & 怎么实现 \\
ADR & 为什么这么设计 \\
\end{tabular}

ADR 是"不可见的工程记忆"。

\subsection{ADR 的核心结构}

典型 ADR 回答四件事：
\begin{enumerate}
\item \textbf{Context（背景）：} 发生了什么问题？为什么要做决定？
\item \textbf{Decision（决定）：} 我们选了什么方案？
\item \textbf{Alternatives（备选）：} 还考虑过哪些方案？为什么没选？
\item \textbf{Consequences（后果）：} 这个决定带来的好处和代价是什么？
\end{enumerate}

\textbf{示例：} \texttt{docs/adr/0005-use-postgres-for-events.md}
\begin{verbatim}
# ADR 0005: Use PostgreSQL for Event Storage

## Context
We need durable event storage with transactional guarantees.

## Decision
We will use PostgreSQL instead of DynamoDB.

## Alternatives
- DynamoDB: rejected due to lack of multi-row transactions.
- Kafka: rejected due to operational overhead.

## Consequences
- Strong consistency
- Higher operational cost
\end{verbatim}

短、明确、可长期保留。

\subsection{ADR 原则与 AI 时代的意义}

\textbf{工程实践原则：}
\begin{itemize}
\item 一条 ADR = 一个决定
\item 决定一旦生效，不随代码随意修改
\item 如果反悔 → 写新的 ADR（supersedes）
\end{itemize}

在 AI 时代，ADR 更重要，因为：
\begin{itemize}
\item AI 看不到当初的讨论
\item AI 容易重提已被否定的方案
\item 人类也会忘
\end{itemize}

ADR 的作用是阻止未来的人（包括 AI）重复走歪路。ADR 不是为了写给别人看的，而是为了防止未来的你、同事、以及 AI 重复犯已经付过代价的错误。

在 spec/agent/git 体系中：
\begin{itemize}
\item \texttt{.specify/}：AI 工作记忆
\item \texttt{docs/wip/}：协作 spec
\item \texttt{docs/adr/}：最终解释权
\end{itemize}

ADR 是 AI 不能越权的"宪法条款"。

\section{工程目录边界}

\subsection{开发工具目录的本质}

\textbf{.idea/}（JetBrains IDE）：工程结构、运行配置、个人快捷键。IDE 私有、高度个人化，通常不 commit，不能当 spec/文档。

\textbf{.vscode/}（VS Code）：settings.json、launch.json、extensions 推荐。个人设置不 commit，团队约定（少量）可 commit（如 formatter），可选但要克制。

\textbf{.cursor/}（Cursor AI 编辑器）：AI 行为配置、prompt 模板、会话状态。本质和 \texttt{.specify/} 一样，是 AI 工具的私有工作区，不应该被当作工程事实，不适合作为长期记忆。

\textbf{.venv/}（Python 虚拟环境）：第三方库、解释器副本。本地运行环境、可再生，永远不 commit，用 \texttt{requirements.txt}/\texttt{pyproject.toml} 描述即可。

\subsection{共同特征}

这些目录的共同点：可再生、不可审计、不应成为"项目真相"。

\textbf{工程判断公式：} "如果我换 IDE/换 AI/换机器，这个东西还应该存在吗？"
✅ 是 → 应该进 repo（docs/code/adr）；❌ 否 → 工具状态（ignore）。

代码和文档是项目的身体，\texttt{.idea}/\texttt{.cursor}/\texttt{.venv} 只是工具的影子；影子会变，身体必须稳定。

\section{Droid Coding 中的文档策略}

\subsection{不需要为了 AI 而刻意维持文档}

在 droid coding 过程中，不需要"为了用 AI"而刻意维持 ADR 或 WIP spec，只需要在"工程本身需要它们"的时候才写。AI 不会要求升级工程复杂度。

\textbf{ADR/WIP spec 的唯一正当理由：} 人类需要、团队需要、未来需要。而不是"AI 最佳实践"、"别人都在用"、"不写就落后"。

\subsection{完全不需要 ADR/WIP spec 的情况}

\begin{itemize}
\item \textbf{单人项目/小项目：} 唯一维护者、变更半天内完成、上下文都在脑中。不写是更高效的工程决策。
\item \textbf{feature 局部、无长期影响：} 不影响架构、不引入新概念、不改变数据模型。让代码和测试说话就够了。
\item \textbf{droid coding 的"短反馈循环"：} 快速试、快速改、squash 掉。ADR 反而是噪音。
\end{itemize}

\subsection{应该写 WIP spec 的情况}

满足以下任意一条：
\begin{itemize}
\item feature 超过 1-2 天
\item 需要停下来明天继续
\item 反复跟 AI 解释同一件事
\item 有人可能中途接手
\end{itemize}

写一个极简 WIP spec，不超过一页：
\begin{verbatim}
# Feature X – WIP
- Goal: ...
- Non-goals: ...
- Open questions:
  - ...
\end{verbatim}

\subsection{必须写 ADR 的情况}

只在这些情况下写 ADR：
\begin{itemize}
\item 做了不可逆或高成本决策
\item 明确否掉了一些看似合理的方案
\item 这个决定未来会被反复质疑
\end{itemize}

这是给未来人（包括自己）用的，不是给 AI。

\subsection{防焦虑原则}

任何"为了 AI 而引入的工程流程"，如果不能明显帮助人类，就应该被拒绝。

ADR 和 WIP spec 是"工程需要时才打开的工具"，不是 droid coding 的前置条件。完全可以继续写代码，而不欠任何"文档债"。

\vspace{1em}
\normalsize
