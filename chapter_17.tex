\small
\section{Git Rebase 与 Spec-Driven 实践}

\subsection{Rebase 的本质与正确用法}

\subsubsection*{git pull 的分解}
\begin{verbatim}
git pull = git fetch + git merge
\end{verbatim}
执行 \texttt{git pull} 实际上是在 merge，不是 rebase。

\subsubsection*{正确的 rebase 同步姿势}
\begin{verbatim}
git fetch origin
git rebase origin/main
\end{verbatim}
或：
\begin{verbatim}
git pull --rebase
\end{verbatim}

\subsubsection*{Rebase 的真正本质}
Git rebase = 把"我这一串 commit" 从"旧的 base" 重新接到"新的 base"上。

\subsubsection*{原始状态}
\begin{verbatim}
main: A -> B -> C
    \
feat:    D -> E (你的提交)
\end{verbatim}

执行 \texttt{git rebase main} 后的结果：
\begin{verbatim}
main: A -> B -> C
    \
feat:    D' -> E'
\end{verbatim}
\begin{itemize}
\item 内容一样
\item commit hash 全变了
\item 历史变成线性的
\end{itemize}

\subsubsection*{stash 的作用}
stash 是"可选的前置操作"，不是 rebase 的一部分。如果工作区有未提交修改，Git 会拒绝 rebase，因此常见的流程是：
\begin{verbatim}
git stash
git rebase main
git stash pop
\end{verbatim}
这是为了让 rebase 能运行，不是 rebase 的定义。

\subsubsection*{Rebase 的正确表述}
"我在 feature 分支上，通过 rebase 把自己的提交，重新基于最新的 main 应用一遍，让历史看起来像是从最新 main 开始开发的。"

\subsubsection*{何时使用 Rebase}
\begin{itemize}
\item 只在你自己的 feature 分支上
\item 在提交还没被别人依赖时
\item 不要在 main / 已共享分支上 rebase
\end{itemize}

\subsubsection*{Spec-Driven 中的 Rebase}
\begin{itemize}
\item 常用于：PR 前整理历史、保持 feature 分支线性
\item 不用于：自动 merge 替代 review
\end{itemize}

\subsubsection*{关键认知}
rebase 的体感像"同步代码"，但本质是"重写你这段提交的历史位置"；stash 只是为了让它能发生，而不是 rebase 本身。

\section{Specify 与 Skills 的关系}

\subsection*{Specify 已覆盖 Skills 的价值}

使用 specify（spec / plan / tasks）后，一般不需要额外写"零散的说明性 skills 文档"，但这不等于"什么都不用写了"。

\subsubsection*{Specify 的职责}
specify 管的是"这个 feature 为什么存在、要做成什么样、怎么一步步实现"。

\subsubsection*{Specify 不替代的内容}
\begin{itemize}
\item README（项目整体介绍）
\item 架构文档（长期存在的）
\item ADR（架构决策记录）
\item API 文档（对外契约）
\item 运维 / 部署文档
\end{itemize}

\subsubsection*{Specify 替代的内容}
"为了完成某一个 feature，临时写的一堆解释性文字和 checklist。"

\subsubsection*{使用 Specify 后的状态}
\textbf{不再做的事}：
\begin{itemize}
\item "这个 PR 做了什么"的长篇说明
\item "开发步骤"散落在 Issue / PR 里
\item 临时的 skills / notes 文档
\end{itemize}

\textbf{仍然会做的事}：
\begin{itemize}
\item 在 \texttt{.specify/specs/xxx/} 里写清楚 spec / plan / tasks
\item 在 PR 里链接这个 spec，一句话总结即可
\end{itemize}

\subsubsection*{判断准则}
当想写一个"skills / 说明"时，问自己："这是为了完成'当前这个 feature'吗？"
\begin{itemize}
\item 是 -> 放进 spec
\item 不是（长期、全局、架构级）-> 单独文档
\end{itemize}

\subsubsection*{定锚}
使用 specify 之后，不需要再额外写"为 feature 服务的 skills 文档"，因为 spec / plan / tasks 本身就是它们的结构化升级版；但它并不取代项目级、长期存在的文档。

\subsection*{Droid 与 Skills 的关系}

如果用 droid 做 spec-coding，绝大多数为单个 feature 服务的 skills 文档都可以不写；只保留那些"跨 feature、长期有效"的技能总结。

\subsubsection*{什么时候仍然需要 Skills}
\begin{itemize}
\item 一个长期有效的开发范式（如："我们项目里如何做权限控制"）
\item 一种跨 feature 的技巧总结
\item Onboarding 给新人的指南
\item 一次重要的技术复盘（post-mortem）
\end{itemize}

\subsubsection*{判断句}
"这段文字，如果 feature merge 之后就没价值了，那它就不该叫 skills。"
\begin{itemize}
\item 没价值了 -> 放 spec / droid 里
\item 还有长期价值 -> 独立 skills / docs
\end{itemize}

\subsubsection*{当前工作流}
\begin{verbatim}
想法 -> droid 对话 -> spec / plan / tasks -> coding -> squash merge
\end{verbatim}
这是一个完整、闭环、低冗余的 spec-driven flow。再额外写 skills，反而会内容重复、版本不同步、增加维护成本。

\subsection*{Vibe -> Spec -> Skills 的关系}

vibe -> spec 是"从感觉到确定性"的过程；skills 是对 vibe 的长期沉淀，而 spec 本身不依赖 skills 才成立。

或更短一点：skills 是 vibe 的长期结晶；spec 是 vibe 的一次性落地。

\subsubsection*{Skills 的作用}
vibe 是直觉、经验、模糊判断；skills 是把这些直觉总结成可复用模式、跨 feature 仍然成立。skills 的目标是：下次一开始 vibe 就更准。

\subsubsection*{Spec 的职责}
spec 的本质是：把"这一次要做什么"钉死。它要求的是：明确、可执行、可 review、可 merge。
\begin{itemize}
\item spec 的输入可以来自 vibe
\item spec 的输出是确定性
\item spec 不需要 skills 作为前置文档
\end{itemize}

\subsubsection*{心智模型表}
\begin{tabular}{l|c|c|c}
层级 & 作用 & 是否长期 & 是否跨 feature \\
\hline
vibe & 直觉 / 感觉 & 否 & 否 \\
spec & 一次性决策 & 否 & 否 \\
skills & 经验沉淀 & 是 & 是 \\
\end{tabular}
spec 在中间，但不依赖 skills 存在。

\subsubsection*{为什么很多人会把 spec 和 skills 混在一起}
在没有 spec-driven 的体系里，vibe -> coding 时，skills 被迫承担：解释、记录、兜底。一旦引入 spec，skills 就可以回到它该在的位置：总结，而不是说明。

\subsubsection*{判断句}
"我现在写的这段东西，是为了'这次能做对'，还是为了'下次能更快 vibe 对'？"
\begin{itemize}
\item 这次 -> spec
\item 下次 -> skills
\end{itemize}

\subsubsection*{最终定锚}
vibe 给方向，spec 给确定性，skills 让下一次 vibe 更强。

\section{Claude Skills 的营销本质}

\subsection*{Claude Skills 的真实本质}

在不用 specify、而是用 Claude Code 的项目里，所谓的 skills，本质就是：人为写的一组"提示规则 + 触发条件"，claude.md 只是一个 prompt router / policy 文件。

\subsubsection*{Skills 的构成}
\begin{itemize}
\item 一段固定的 prompt 模板
\item 一些 if / when / condition
\item 一些行为约束
\item 一点"人类写的经验总结"
\end{itemize}
本质上就是：prompt engineering + routing + 规则堆叠。

\subsubsection*{关于"省 token"的说法}
这是一个半真半假的说法。

\textbf{他们说对的一半}：skills 在"重复场景"里确实可以省 token。例如：
\begin{itemize}
\item 每次都要 Claude 按某种格式写代码
\item 每次都要它遵守一套规范
\item 每次都要提醒"你是资深工程师 + 不要 hallucinate"
\end{itemize}
如果把这些写成固定规则，不用每次手动输入，"相对手打 prompt"是省 token 的。

\textbf{他们刻意不说的另一半}（重点）：skills 省 token 的前提是：原本就打算反复注入同一堆指令。但在 spec-coding 里，写的是明确 spec、明确任务，Claude 不需要靠"skills 猜"。所以：spec coding 消耗 token 是因为在"外包思考"，而不是因为它低效。这是两个完全不同的 token 消耗来源。

\subsubsection*{Spec Coding 不等于 Token 浪费}
spec coding 用 token 买的是"确定性"和"少返工"。而 skills 的 token 节省，往往是：省了 prompt token，但增加了：错误概率、不可控行为、隐性 debug 成本。这是典型的"显性 token 减少，隐性成本 增加"。

\subsection*{为什么 Skills 不可靠}

\subsubsection*{Skills 的四个问题}
\begin{enumerate}
\item \textbf{没有稳定接口（不像 API / spec）}：模型一升级，行为就可能变化，skill 立刻失效。没有 backward compatibility。

\item \textbf{通常是「经验叠加」，不是「契约」}："我觉得这样 Claude 表现好"，而不是：明确输入、明确输出、明确边界。这在工程上是软约束。

\item \textbf{作者无法为你的场景负责}：博主的项目背景、你的项目复杂度完全不同。skills 不可迁移性极强。

\item \textbf{是「人设营销」的绝佳载体}："不学习 Claude skills 就会明显落后"，这是一个非常典型的 marketing narrative：制造信息差、暗示稀缺、承诺捷径。而工程现实是：没有捷径，只有 trade-off。
\end{enumerate}

\subsection*{Claude Skills 才是未来？}

"Claude skills 才是未来"这句话，营销成分远大于工程事实。从可靠性和可持续性看，spec-coding 明显更稳。

Claude Code（+ spec-coding）代表的是"确定性工程路径"；所谓 Claude skills，更多是"个人 prompt 经验的商品化包装"。两者不是同一层级的东西。

\subsubsection*{为什么这套话术"听起来很合理"}
因为它利用了 3 个真实现象（但给出了错误推论）：

\textbf{真实现象 1：LLM 越来越强}
错误推论："所以我们不需要 spec 了"
事实上：模型越强，spec 的性价比越高，因为它能更好地执行明确约束。

\textbf{真实现象 2：prompt 技巧确实有用}
错误推论："prompt 技巧 = 长期工程能力"
prompt 技巧的问题是：高度依赖模型版本、不稳定、不可验证。

\textbf{真实现象 3：skills 短期确实提效}
错误推论："短期提效 = 可持续路径"
这在工程史上非常常见（宏、脚本、魔法参数）。

\subsubsection*{为什么 spec-coding 更像"未来"}
从工程演进规律看，spec-coding 符合长期趋势。

\textbf{1. spec 是"外部化思考"，skills 是"内部化经验"}
\begin{itemize}
\item spec：可 review、可版本化、可回滚
\item skills：在 prompt 里、在人脑里、不透明
\end{itemize}
工程永远偏向"可审计"。

\textbf{2. spec 是模型无关的，skills 是模型绑定的}
\begin{itemize}
\item spec：GPT / Claude / Gemini 都能用
\item skills：Claude vX 有效，vY 可能失效
\end{itemize}
未来不可能押宝在单一模型技巧上。

\textbf{3. spec 是组织级资产，skills 是个人资产}
团队真正会保留的只有：spec、design doc、ADR；而不是："某人会用 Claude 的第 17 条 skills"。

\subsubsection*{为什么更像营销}
\begin{enumerate}
\item 制造稀缺感："你还没学会 skills"
\item 制造复杂感："skills 很多、很深、很高级"
\item 制造路径依赖："我教你这套"
\end{enumerate}
这是卖内容的经典结构，不是工程路线图。

\subsubsection*{反证}
如果 skills 真的是未来，那么你应该看到：
\begin{itemize}
\item 官方文档大力推 skills？否
\item 大厂工程流程围绕 skills？否
\item LLM 平台承诺 skills 的稳定接口？否
\end{itemize}
现实是：官方一直在强调：结构化输入、明确约束、可复现。也就是 spec-like 思维。

\subsubsection*{可靠感的来源}
spec 有失败边界，skills 没有。工程师天生会信任：可失败、可修正、可复盘的系统。

\subsubsection*{判断准则}
以后再听到类似话术，可以问一句："如果模型换了、上下文变了、团队换人了，这套方法还成立吗？"
\begin{itemize}
\item 成立 -> 工程方法
\item 不成立 -> marketing / hack
\end{itemize}

\subsubsection*{最终定锚}
spec-coding 是工程方法，skills 是个人技巧；工程方法会成为未来，个人技巧只会周期性被营销。

\subsubsection*{什么时候 Skills 才值得写}
只在 2 种情况下写 skills：
\begin{itemize}
\item 情况 1：你自己反复踩同一个坑 $\ge$ 3 次 -> 写一条 personal rule
\item 情况 2：这是跨项目、长期有效的模式 -> 写成经验总结 / playbook
\end{itemize}
否则：宁愿多写 spec，也不要堆 skills。

\section{Multi-Agent 与 Sub-Agent 详解}

\subsection{Multi-Agent 的工程现实}

\textbf{宣传版本}：多个 AI agent 像一个团队一样协作开发软件。

\textbf{工程现实}：多上下文、多份状态、多次推理、人工合并。当前 multi-agent 的"成功案例"几乎全部是：demo、实验、短期任务。真正长期稳定的工程系统仍然是：内部逻辑高度单一、有明确控制中心、强一致性。

这和单 agent + spec 非常一致。

\subsection{Multi-Agent 带来的问题}

multi-agent 系统通常意味着：多个上下文、多份状态、多次推理、最终人工合并。这会带来：

\begin{itemize}
    \item 冲突代码/设计冲突
    \item 语义漂移（agent 各自理解不同）
    \item 协调成本高（人要当项目经理）
    \item 调试困难（不知道错在哪个 agent）
\end{itemize}

\subsection{Multi-Agent 的适用场景}

\textbf{适合 multi-agent}：
\begin{itemize}
    \item 信息收集型任务（agent A 查文档、agent B 找示例、agent C 总结）
    \item 彼此独立、无共享状态的任务
    \item 探索阶段的 brainstorming
\end{itemize}

\textbf{不适合 multi-agent}：
\begin{itemize}
    \item 核心业务逻辑、同一代码路径的修改
    \item 状态耦合系统、长期维护项目
    \item 软件工程 90\% 的场景都在这里
\end{itemize}

\subsection{Sub-Agent 的核心价值}

sub-agent 的核心意义，不是"更聪明"，而是：不新开上下文、复用主 agent 的世界模型，从而减少记忆装载、降低 token 和语义漂移成本。

\subparagraph{为什么「新开 agent」在工程上很贵}

当你"新开一个 agent"时，通常会发生：
\begin{itemize}
    \item 上下文重新注入：项目背景、代码结构、约束条件
    \item 世界模型重新对齐：命名、语义假设
    \item 行为重新校准：风格、输出格式
\end{itemize}
这些都要 token，而且是高价值 token。

\subparagraph{Sub-Agent 的架构定位}

sub-agent 通常是：主 agent 内部的一次"受控分支推理"。它的特点是：
\begin{itemize}
    \item 共享上下文，不需要重新解释世界
    \item 生命周期短，用完即丢
    \item 无长期记忆，不会污染主 agent
    \item 明确边界，像函数调用
\end{itemize}
更像是 \texttt{callSubtask()}，不是 \texttt{spawnNewWorker()}。

\subparagraph{Token 角度}

sub-agent 确实可以省 token，但方式是：
\begin{itemize}
    \item 不是"思考更少"
    \item 是"不重复解释"
\end{itemize}

对比一下：
\begin{itemize}
    \item 新 agent：
    \begin{verbatim}
[重载项目背景]
[重载代码上下文]
[重载约束]
-> 才开始干活
    \end{verbatim}
    \item sub-agent：
    \begin{verbatim}
[已知上下文]
-> 直接干活
    \end{verbatim}
\end{itemize}

\subparagraph{澄清}

sub-agent 不是为了"极限省 token"而存在的。它省 token 是副作用，不是目标。真正目标是：
\begin{itemize}
    \item 保持语义一致性
    \item 减少 cognitive drift
    \item 让主 agent 仍然是"唯一真相源"
\end{itemize}

\subparagraph{Sub-Agent 比 Multi-Agent 安全}

因为：sub-agent 不拥有世界观、不做全局决策、不影响架构。它只负责：执行、变换、辅助。所以几乎不会出现竞争冲突。

\subparagraph{Sub-Agent 适用场景}

\textbf{典型高性价比场景}：
\begin{itemize}
    \item 生成测试用例
    \item 重构局部函数
    \item 总结 diff
    \item 检查代码风格
    \item 抽取 TODO / checklist
\end{itemize}

\textbf{不适合}：
\begin{itemize}
    \item 设计 API
    \item 改动核心模型
    \item 影响多个模块的决策
\end{itemize}

\subparagraph{最终定锚}

sub-agent 的价值在于：用最少的上下文切换，完成最安全的辅助工作；它是"工程优化"，不是"范式革命"。

\subsection{droid 与 Claude Code 的 Sub-Agent 机制}

\subparagraph{droid 对 sub-agent 的支持}

droid 本身不显式暴露 sub-agent 概念，但用户的使用方式本质上已经在"手动模拟 sub-agent"。在单上下文工作流中，用户通过明确指令（"现在只做 X"、"不要改别的"）实现受控的子任务执行，用完即丢。这在认知模型上就是 sub-agent，只是没有被工具层包装。droid 选择的是"人当 orchestrator，而不是系统当 orchestrator"，这对复杂工程反而更稳。

\subparagraph{Claude Code 的 sub-agent 定义}

在 Claude Code 中，sub-agent 是一个有独立 system prompt 和工具权限的"受控子上下文"，生命周期短、不共享长期记忆、通常由主 agent 自动或半自动调用。它不是第二个可对话的 Claude，也不是真正的"协作智能体"。

\subparagraph{Calling 方式}

\begin{enumerate}
    \item \textbf{自动调用：} Claude Code 根据任务类型自动触发内置 sub-agent（如 Plan 只读分析、Explore 快速搜索）。这些通常是只读的，不参与架构决策，本质是节省主上下文并减少污染。
    \item \textbf{显式指定：} 可直接说"使用 code-reviewer sub-agent 检查 auth 模块"。前提是在 \texttt{.claude/agents/} 或 \texttt{\textasciitilde{}/.claude/agents/} 中定义。sub-agent 本质是 Markdown 文件加 YAML 头：
    \begin{verbatim}
---
name: code-reviewer
description: Review code for security and maintainability
tools: Read, Grep, Glob
---
你的 system prompt 写在这里
    \end{verbatim}
    \item \textbf{/agents 命令：} 可查看所有 sub-agent，新建/编辑/删除，控制工具权限。
\end{enumerate}

\subparagraph{sub-agent 与 token 节省的关系}

sub-agent 不是复用完整主上下文，而是不需要重复用自然语言解释项目，由系统用结构化方式注入最小上下文。省的是"高价值解释 token"，不是推理 token。

因此，sub-agent 多用于搜索、重构局部、生成测试，不用于 spec、架构、业务决策。

\subparagraph{sub-agent 的局限性}

sub-agent 并不是"不用就落后"的能力。很多高级用户反而主动限制 sub-agent，因为不能中途对话、取消即丢失状态、debug 成本高。有人在 \texttt{CLAUDE.md} 中明确写"DO NOT create subagents without explicit instruction"。

在 droid 单上下文、spec 驱动、人控节奏的工作方式中，sub-agent 是工具层优化，不是方法论升级，也不是必须品。

\textbf{核心原则：} sub-agent 的意义是减少上下文切换和重复解释，而不是替代判断或 spec。不用它不代表落后，理解它反而更不容易被营销带偏。

\subsection{单 Agent vs Sub-Agent vs Multi-Agent 的关系}

当前工作流：
\begin{verbatim}
人（vibe / 判断）
    |
    v
spec（明确边界）
    |
    v
单 agent 执行
    |
    v
人 review / merge
\end{itemize}
这套模式：可控、可复现、可扩展、抗模型变化。

\subparagraph{定锚}

multi-agent 的想象力很大，但目前的工程现实很小；你对冲突和竞争的担忧，正是它还没成熟的证明。你现在没有"落后"，你是在避开一条尚未工程化完成的路径。

\subparagraph{与 Droid 用法对齐}

你现在：单 agent、spec 明确、人在控制节奏。你已经在用 sub-agent 的"精神模型"，只是工具没显式这么叫。

\subsection{LSP 的作用}

LSP 本质是：自动补全、跳转、类型提示、语法检查。它解决的是"编辑器智能"，不是：设计、架构、spec。用 droid 多，本质是把 LSP 能做的事，交给了脑子 + spec。并没有缺能力，只是工具选择不同。

\section{工程心智模型}

\subsection*{正确的工作流位置关系}
\begin{verbatim}
vibe
    |
    v
spec / task definition <--（这里最值 token）
    |
    v
LLM 执行
    |
    v
skills（可选、事后总结）
\end{verbatim}
而不是博主暗示的那种：skills -> 自动变强 -> 不写 spec。那是反工程的叙事。

\subsection*{判断准则}
"这段文字，如果 feature merge 之后就没价值了，那它就不该叫 skills。"
"我现在写的这段东西，是为了'这次能做对'，还是为了'下次能更快 vibe 对'？"
"如果模型换了、上下文变了、团队换人了，这套方法还成立吗？"

\subsection*{关键洞察}
\begin{itemize}
\item spec 是"工程契约"，skills 是"个人经验"
\item 被营销放大的 skills，往往是在掩盖 spec 的缺席
\item spec-coding 用 token 买的是"确定性"和"少返工"
\item skills 的 token 节省，往往是"显性 token 减少，隐性成本 增加"
\item multi-agent 的想象力很大，但工程现实很小
\item sub-agent 是"工程优化"，不是"范式革命"
\end{itemize}

\subsection*{工程 vs 营销}
\begin{itemize}
\item 工程方法：可失败、可修正、可复盘、可审计、版本化、可回滚
\item 营销叙事：制造稀缺感、制造复杂感、制造路径依赖、暗示捷径、承诺效果
\end{itemize}

真正强的 Claude / LLM 使用者，往往 skills 很少，spec 很清楚。因为他们明白：模型最擅长明确任务、明确约束，最不擅长模糊经验、玄学规则。
