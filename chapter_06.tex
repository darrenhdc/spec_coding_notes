% chapter_06.tex
% Lines 45581 to 54717 of original content

\small

\section*{Spec Coding 工具生态与实战方法}

\subsection*{一、Spec Coding Agent 的四层分类}

真正的 spec‑coding agent 极少。按「spec 是否为第一真理」分层：

\subsubsection*{第一层：真正 Spec Agent（只有 Droid）}

\textbf{核心特征}：spec 是可演化的工程真理，agent 对 spec 负责，可以修改 spec 但必须承诺一致性。

\textbf{代表}：Droid（Rift）

\textbf{机制}：
\begin{itemize}
\item spec 文件是 agent 的输入和输出
\item agent 可以修改 spec，但必须说明原因
\item spec 参与所有后续推理
\end{itemize}

但：不对外、没有通用产品形态。

\textbf{结论}：公开、可用、通用的，基本只有 Droid。

\subsubsection*{第二层：半 Spec Agent（看起来很像，但差一口气）}

有 spec 结构，但 spec 不是真正「可演化真理」，agent 不能对 spec 负责。

\textbf{典型代表}：

\textbf{1. SWE‑agent / AutoCodeRover / OpenDevin}：有 task description 和 constraints，但 spec 是 prompt 不是长期资产，agent 不会维护它。这是「任务驱动 agent」，不是 spec coding。

\textbf{2. Devin（Cognition）}：会规划、会分解任务，但 Plan ≠ Spec，没有可维护的工程不变量。Devin 是 autonomous worker，不是 spec executor。

\subsubsection*{第三层：Plan / Blueprint 工具（Claude Code 在这里）}

显式 plan、人确认，但 agent 不维护 plan、plan 会过期。

\textbf{代表}：Claude Code Plan Mode、Cursor 的 planning step、ChatGPT 的 "let's plan first"。

这是 vibe → spec 的过渡层。

\subsubsection*{第四层：「伪 spec」（营销用语，务必小心）}

这些会用词如 "AI understands your requirements"、"Declarative development"、"No‑code spec"，但实际上 spec = prompt，不可验证、不可回滚、不参与 agent 推理。和 spec coding 没有工程意义上的关系。

\subsection*{二、为什么真正的 spec‑coding agent 这么少？}

\subsubsection*{1. Spec 本身就很难}

Spec 是最难的工程产物之一。人都写不好，更别说让 agent 维护。

\subsubsection*{2. 心智负担太高}

Spec‑coding agent 要求用户接受「代码不是第一真理」，学会约束思维、不变量思维。这直接淘汰 90\% 用户。

\subsubsection*{3. Demo 不好看}

spec 收敛模型不会「神奇写一切」，投资人和用户都不兴奋。

\subsubsection*{4. 责任与法律风险}

一旦 agent 可以修改 spec 并承诺一致性，就面临着责任归属问题。

\subsection*{三、Claude Code 的 /compact 指令详解}

\subsubsection*{/compact 的作用}

把当前对话中「对后续实现不再重要的上下文」压缩成一个更短的内部摘要，以释放上下文窗口。

\textbf{关键点}：
\begin{itemize}
\item 减少 token 占用
\item 保留关键信息
\item 不是保存 plan
\item 不是生成 spec
\item 不可逆
\end{itemize}

\subsubsection*{/compact 实际发生了什么}

\textbf{不使用 /compact}：所有历史消息原样塞进上下文，Token 越来越大，模型注意力被稀释。

\textbf{使用 /compact 后}：Claude 会读取当前对话，判断哪些内容已完成、已不再需要逐字保留，生成一个内部摘要表示，用这个摘要替换掉原始长对话。

结果是：总 token 大幅减少，关键信息还在，但原始细节消失。这是「记忆压缩」，不是「记忆保存」。

\subsubsection*{/compact 适合什么时候用}

\textbf{非常适合的场景}：
\begin{enumerate}
\item 已完成一个阶段性目标（完成一次重构、跑通一个 feature、Debug 已结束）
\item 对话变得很长，但要继续干活
\item 避免模型「记太多垃圾」——长对话里往往有被否定的想法、试错代码、临时 workaround
\end{enumerate}

\textbf{绝对不要用的场景}：
\begin{enumerate}
\item 还没把 plan / spec 落到文档——plan 还只存在于对话里，/compact = 可能永久丢失关键设计理由
\item 对话里有「微妙但重要的约束」（某个 edge case 的来龙去脉、为什么不用某种方案）——摘要极可能丢掉这些细节
\item 你指望 Claude 「记住一切」——它不会
\end{enumerate}

\subsubsection*{/compact 的正确使用模式}

「文档先行，再 /compact」：

标准流程：用 Plan Mode / 对话把事情想清楚 → 把关键信息写进 SPEC.md、ARCH.md、TODO.md → 明确告诉 Claude「以这些文档为准」→ 再使用 /compact。

这样你把「工程真理」交给文档，把「短期记忆」交给 Claude。

\textbf{总结}：/compact 是 Claude Code 的「上下文垃圾回收器」，用来省 token、提效率，而不是用来保存理解或设计。

\subsection*{四、/compact 后检测理解偏移的方法}

/compact 后的理解偏移，最有效的检测方式不是问「你懂不懂」，而是让 Claude 在不看历史的情况下，复述并「约束性推理」。

\subsubsection*{30 秒「快速三连问」}

\textbf{第 1 问：状态复述（State Check）}

「请用不超过 5 条要点，复述当前项目的目标、已完成内容和接下来要做的事。」

你要看的是：是否抓住真正目标，有没有把已废弃的方案当成当前方案。

\textbf{第 2 问：硬约束复述（Invariant Check）}

「列出当前实现中必须保持不变的 3–5 个关键约束或不变量。」

这是最容易暴露偏移的地方。如果它提到你最在意的约束 → 好；漏掉 / 编造 → 已经偏移。

\textbf{第 3 问：反例推理（Counter‑example Check）}

「如果违反其中一个约束，会出现什么具体问题？请给一个例子。」

这一问能区分：真理解（能举出合理失败场景）vs 表面理解（空话、泛泛而谈）。

\subsubsection*{10 秒「红旗信号」}

看到任意一条就要立刻停下：使用模糊词（「一般来说」「通常情况下」）、把「实现细节」说成「可选项」、新增你没说过的目标、忘记之前你反复强调的限制。这些 99\% 是 /compact 摘要丢信息导致的。

\subsubsection*{补救方式}

1. 直接指出：「你刚才遗漏/误解了这几个关键点：……」
2. 要求重新对齐：「请基于这些补充，重新总结当前理解，再继续。」

不要让它「边改边想」，一定要先复述再动手。

\subsection*{五、Context vs Memory vs Spec}

\subsubsection*{三个核心概念}

\textbf{1. Context（上下文）}：当前模型能「看到」的所有 token，包括对话历史、系统提示、/compact 摘要。

特点：不可查看、不可版本化、不可靠，适合短期推理。

Context 是「工作记忆」，不是资产。

\textbf{2. Memory（记忆）}：你希望模型长期、不漂移记住的东西。

特点：必须显式存在（文件 / DB）、可编辑、可 diff、可回滚。

Memory 是「工程真理的一部分」。

\textbf{3. Spec（规范）}：Memory 的「强约束子集」，用来定义不变量、边界条件、行为契约。

Spec = 高强度 Memory。

\subsubsection*{Memory 管理等于上下文管理吗？}

完全不等价。

\textbf{上下文管理}你能做的只有三件事：控制对话长度、合理使用 /compact、频繁做理解验证。你无法真正管理 context。

\textbf{Memory 管理}你能做的事情：定义结构、持久化、明确优先级、强制 agent 读取。这是你能真正掌控的部分。

\subsubsection*{Claude Code 下的可行 Memory 管理体系}

\textbf{1. 分层 Memory}：
\begin{verbatim}
/docs
 ├── SPEC.md            ← 不变量 / 合同
 ├── ARCH.md            ← 架构决策
 ├── CURRENT_STATE.md   ← 当前阶段状态
 ├── DECISIONS.md       ← 为什么这么做
\end{verbatim}

\textbf{各自职责}：
\begin{itemize}
\item SPEC.md：极少改、高门槛
\item ARCH.md：记录结构选择
\item CURRENT\_STATE.md：高频改、/compact 后必读
\item DECISIONS.md：防止反复争论
\end{itemize}

\textbf{2. 明确 Memory 优先级}：

每次新对话 / /compact 后，都明确告诉 Claude：「当对话历史、直觉判断与 docs/ 中的内容冲突时，以 SPEC.md → ARCH.md → CURRENT\_STATE.md 的顺序为准。」这一步是在人为注入 spec‑coding 语义。

\textbf{3. 把 Memory 当成「输入」，不是「背景」}：

不要说「你应该记得我们之前说过……」，要说「请先读取 docs/CURRENT\_STATE.md 和 docs/SPEC.md，再继续。」Memory 必须被当成显式输入。

\textbf{4. /compact 在 Memory 管理中的真实角色}：

/compact ≠ Memory 管理工具。它的真实作用是：清空短期噪音、释放上下文、强迫你把该留下的东西写进 Memory。

好用法：Memory 固化 → /compact → 继续。

坏用法：全靠对话 → /compact → 迷失。

\textbf{5. 判断标准}：

问自己一句话：「如果我现在换一个模型，只给它 docs/ 目录，它能继续干活吗？」

能 → Memory 管理合格；不能 → 你在靠 context 硬撑。

\subsection*{六、可以查看 /context 吗？}

不可以。Claude Code 目前无法查看 /context，也不存在任何命令可以直接显示「当前上下文内容」。

\subsubsection*{为什么 Claude Code 不允许查看 context？}

\textbf{1. 上下文不是稳定对象（工程原因）}：Claude 的 context 包含系统提示（你永远看不到）、工具注入的隐式指令、安全 / 对齐层内容、/compact 生成的内部摘要表示。这些内容不可编辑、不可版本化、不是人类可维护的结构，展示出来反而会误导用户。

\textbf{2. 避免「伪可控感」（产品哲学）}：如果你能看到 context，你会自然地以为「我现在看到的，就是 Claude 理解的全部」。但实际上模型 attention 是概率性的，上下文权重随推理动态变化。Anthropic 非常刻意地避免这种控制幻觉。

\textbf{3. 法律与安全原因（现实层）}：Context 中可能包含内部系统指令、安全策略、模型引导语，绝对不会对用户暴露。

\subsubsection*{那怎么「等价于查看 context」？}

虽然不能看，但你可以用三种方式「测出来」：

\textbf{方法 1：状态复述（最常用）}：「请复述你当前理解的项目状态、目标和关键约束。」这是在让模型显式化它的内部 context。

\textbf{方法 2：约束性推理（最准）}：「如果我要求你在不违反当前约束的前提下做 X，你会先检查哪些地方？」能正确列出检查顺序 ≈ context 对齐；直接动手写代码 ≈ context 漂移。

\textbf{方法 3：文件锚定（最稳）}：在项目中放一个你可控的锚点 CURRENT\_STATE.md，然后明确说一句：「当前实现必须以 CURRENT\_STATE.md 为唯一真实上下文来源。」这样你把不可见的 context 替换为可见、可维护的工程资产。

\subsubsection*{/compact 后的一个重要提醒}

/compact 后，你永远无法知道 Claude 「删掉了什么」，你只能验证「它还记得什么」。

所以正确顺序永远是：文档固化 → /compact → 理解验证。

\subsection*{七、对比其他工具}

\begin{tabular}{lcc}
工具 & 能否查看 context & spec 是否可查看 \\
\hline
Claude Code & ❌ & ❌ \\
Kiro & ❌（context） & ✅ \\
Droid & ❌（context） & ✅（且 agent 维护） \\
\end{tabular}

没有任何主流系统允许查看 raw context。工程系统选择的是：可查看 spec，而不是 context。

\subsection*{八、终极总结}

Claude Code 没有、也不会提供 /context 查看能力；正确做法不是「看 context」，而是把关键理解迁移到你可控的文档中。

/compact 是 Claude Code 的「上下文垃圾回收器」，用来省 token、提效率，而不是用来保存理解或设计。

/compact 后检测理解偏移，最快的方法是：让 Claude 复述状态 → 复述约束 → 解释违反后果；能做「约束性推理」的，才是真的对齐。

上下文是模型的短期注意力，Memory 是工程的长期真理；真正的 AI 编程能力，不是「管理 context」，而是「设计 Memory」。
