% chapter_10.tex - Spec Coding 范式转移与最佳实践
\small

\chapter{Spec Coding 范式转移与最佳实践}


\section{Droid 与 Spec-Driven Development}

Droid 是一种端到端的自动 agent，它已经内置了"Spec → Plan → Execute"的思想。Droid 不需要 spec-kit，因为它的执行能力已经包含了这些阶段。

但 Droid 的产物是"机器状态"，而非"人读的 spec"。如果需要：
\begin{itemize}
  \item audit 和 PR review
  \item 长期知识沉淀
  \item 多 agent 协作
\end{itemize}

则仍然需要显式的 spec / plan 文档作为共享真相源。

\section{Claude Skills 的本质}

Claude Skills 不是"Claude 的内在能力"，而是外部注册给 Claude 的"可调用模块"。Skills 的价值在于：
\begin{itemize}
  \item 把个人经验沉淀为可复用模式
  \item 让下一次 vibe 更准确
\end{itemize}

但需要注意：
\begin{itemize}
  \item Skills 高度定制化、非官方、不可验证
  \item 很多"Skills 焦虑"是营销叙事，而非工程必需品
  \item Spec Coding 已经将"零散 skills"系统化了
\end{itemize}

\textbf{判断原则}：这段文字是为了"这次能做对"（spec），还是为了"下次能更快 vibe 对"（skills）？前者用 spec，后者才考虑 skills。

\section{Spec-Driven 工作流最佳实践}

\subsection{正确的开发流程}

\begin{enumerate}
  \item git checkout -b feat/xxx
  \item spec / plan / tasks（可 commit）
  \item implement
  \item review（git diff / PR）
  \item commit implementation
  \item squash merge
\end{enumerate}

这套流程：
\begin{itemize}
  \item 可控、可复现、可扩展
  \item 抗模型变化
  \item 所有不确定性留在分支里
  \item 所有确定性才进 main
\end{itemize}

\subsection{Spec 冲突的处理}

当 .specify/ / droid specs 与协作态 / 契约态 spec 冲突时：

\textbf{优先级规则}：契约态 > 协作态 > 工具态

这条规则必须显式告诉 AI。当 AI 发现冲突时，应该：
\begin{itemize}
  \item 明确指出冲突文件和冲突点
  \item 提供建议方案
  \item 等待人类确认
\end{itemize}

不要让 AI "协调 spec 冲突"，要让 AI "暴露 spec 冲突"。

\subsection{/resume 的本质}

/resume 恢复的是"对话状态"，不是"项目状态"。它不能：
\begin{itemize}
  \item 恢复 .specify/
  \item 恢复 droid specs
  \item 重新读懂未 commit 的 WIP spec
  \item 替代 ADR / README / CLAUDE.md
\end{itemize}

适合用 /resume 的场景：断线、页面刷新、模型超时。不适合：隔了一天、换了机器、项目状态有变化。

\section{核心理念总结}

\begin{quote}
  spec 是工程契约，skills 是个人经验；工程方法会成为未来，个人技巧只会周期性被营销。
\end{quote}

\begin{quote}
  .specify/ 是给工具用的，./docs 是给工程师用的；只要是"未来的人要看的 spec"，就绝不应该藏在 .specify/ 里。
\end{quote}

\begin{quote}
  临时 spec 是工作记忆，main 只保留长期记忆；squash merge 的意义，不仅是压缩 commit，也是压缩思考噪音。
\end{quote}

\vspace{1em}
\normalsize
