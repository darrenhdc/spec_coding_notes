% chapter_12.tex - 底层库与工具生态实战
{\small

\chapter{底层库与工具生态实战}

\section{底层库场景下的 AI Agent 工程判断}

在 transformers 这种“接口经常变、体量巨大、语义靠源码而不是注释”的库里，用 AI agent / vibe coding 的“性价比和安全性”反而低于古法手写 + 文档 + grep。

\subsection{场景特征分析}

模型/底层库代码的特点：
\begin{itemize}
    \item 接口是软约定（不总写清楚）
    \item 行为靠实现细节
    \item 一点点错 = silent bug / 数值错 / 性能灾难
    \item API 多、历史包袱重、同名函数多版本
    \item 文档永远落后于实现
    \item 接口不稳定、breaking change 频繁
    \item PR / release / main 分支行为不一致
\end{itemize}

transformers 库的特殊性：
\begin{itemize}
    \item 代码路径深、side effect 多
    \item inheritance / mixin 爆炸
    \item hook / callback 横飞
\end{itemize}

\subsection{为什么 AI agent 在此类场景下不可靠}

AI agent 的知识几乎必然是“滞后 + 混合态”的：
\begin{itemize}
    \item 混合多个版本
    \item 不知道哪些已废弃
    \item 很容易“合理胡说”
\end{itemize}

AI agent 不会像人一样：
\begin{itemize}
    \item rg class\_name 跳进源码
    \item 看 call graph
    \item 追 commit diff
\end{itemize}

即使能，也做得慢、不可靠、容易 hallucinate。

\subsection{“古法开发”的实际含义}

不是不用工具，而是用对工具：
\begin{itemize}
    \item IDE + LSP
    \item grep / ripgrep
    \item 看源码
    \item 看 commit history
    \item 跑最小复现脚本
    \item 手写改动
\end{itemize}

这是“底层工程的 vibe”。

\subsection{适用域不同}

Spec Agent 适用：
\begin{itemize}
    \item 自动化
    \item 多文件协作
\end{itemize}

古法开发适用：
\begin{itemize}
    \item 单点接口
    \item 高频变更
    \item 模型行为一致性
\end{itemize}

两者面对的是两个完全不同的工程地形。

\subsection{一句话总结}

在接口频繁变化、行为靠源码定义、错误不显性的模型库里，AI agent 的不确定性会被放大；所以经验工程师选择古法开发，不是保守，而是风控。

\section{DeepWiki：AI 文档工具}

\subsection{DeepWiki 是什么}

DeepWiki 是一个把 GitHub 仓库自动索引成“可对话文档”的工具。它会解析 repo 的代码、结构、README、关键文件，让你可以直接用自然语言问：
\begin{itemize}
    \item 这个仓库是干嘛的？
    \item 某个模块怎么用？
    \item 某个类/函数在哪里定义、为什么这么设计？
\end{itemize}

\subsection{核心价值}

DeepWiki 的核心价值是“读库”，不是“写库”。它擅长的事情是：
\begin{itemize}
    \item 帮你快速理解一个大型 repo
    \item 定位代码位置和模块职责
    \item 总结当前版本的结构和约定
\end{itemize}

它不等同于 AI agent 自动改代码，而是更像一个“随时可问的 repo 专家”。

\subsection{与古法开发的关系}

DeepWiki + 古法开发是“互补关系”。在 transformers 这类库里，更安全的工作流是：
\begin{itemize}
    \item 人类主导决策和改动
    \item IDE/LSP/grep 做精确定位
    \item DeepWiki 用来快速理解整体和上下文
\end{itemize}

而不是：
\begin{itemize}
    \item agent 自动生成改动
    \item 人类事后兜底
\end{itemize}

\section{TRAE 国内版与地域访问控制}

\subsection{403 错误的原因}

TRAE 国内版官网是强地域访问控制。403 说明被判定为“非支持区域”。这和账号无关，就是区域策略。

香港 IP ≠ 国内 IP。TRAE 国内版官网下载入口页面通常是按“大陆 / 非大陆”直接切的。

\subsection{可行的解决方案}

方式 1（最稳，推荐）：国内网络代下载
\begin{itemize}
    \item 找一个在中国大陆的朋友 / 同事或一台国内云服务器
    \item 打开 https://www.trae.com.cn/
    \item 下载对应的 macOS / Windows 安装包
    \item 通过文件传给你
\end{itemize}

方式 2：国内机器远程使用
\begin{itemize}
    \item 国内机器安装 Trae 国内版
    \item 你用远程桌面 / VS Code Remote 操作
\end{itemize}

方式 3：换成“只用豆包 API，不用 Trae”
\begin{itemize}
    \item 直接走豆包 API
    \item 在你当前环境自己封工具/agent
    \item 完全绕开 Trae 的地域问题
\end{itemize}

\subsection{在国内安装后带到香港的使用}

可以在国内下载并安装 Trae 国内版，但回到香港后，“能不能用”取决于你用到 Trae 的哪一层能力。

分层说明：
\begin{enumerate}
    \item 客户端本身：✅ 可以用。不会启动即崩，不会强制卸载。
    \item 登录与基础功能：⚠️ 大概率可用，但不保证
    \item 豆包模型调用：⚠️ 取决于当时策略（关键）
    \item 更新与新功能：❌ 风险最高
\end{enumerate}

经验结论：在国内下载并完成首次登录，回到香港继续日常使用，但准备一个 fallback（国内机器 / 国内网络）。

\section{TRAE 命令行版本问题}

\subsection{结论}

截至目前（2026-01-06），TRAE 没有官方提供的、独立的命令行（CLI）版本。

\subsection{原因}

TRAE 的定位是「IDE + 内嵌 AI 能力」：
\begin{itemize}
    \item TRAE 本质是一个图形化 IDE（类似 VS Code 的分支/封装）
    \item AI 能力是强绑定在 IDE 交互里的
    \item 不是一个独立可调用的 CLI 工具
\end{itemize}

TRAE 的卖点是：
\begin{itemize}
    \item 上下文感知（编辑器状态）
    \item 文件树
    \item diff / patch
    \item 人在回路里的交互
\end{itemize}

这些能力强依赖 IDE 运行态。

\subsection{替代方案}

如果你真正想要的是 CLI 可脚本化、可自动化、能跑在服务器 / CI / SSH 里，那现实选择是：

1）直接用模型 API（豆包 / OpenAI / Claude / DeepSeek，自己封 prompt / workflow）

2）用已有的 agent CLI 框架（OpenAI Codex CLI、aider、continue（CLI 模式）、自建脚本 + LLM）

\section{GitHub Copilot 功能详解}

\subsection{New chat}

最基础的 Copilot Chat，会话级对话窗口。

能力特点：
\begin{itemize}
    \item 基于当前打开的文件 / 选区回答问题
    \item 代码解释、补全、重写
    \item 不自动跨文件执行修改
    \item 不长期记忆上下文（换 chat 就没了）
\end{itemize}

适合：临时问问题、解释某段代码、小范围修改建议

不适合：多文件重构、有状态的长期任务、复杂工程决策

\subsection{Agents}

Copilot 的“多步任务执行模式”，但仍然是交互式 agent。

能力特点：
\begin{itemize}
    \item 可以规划步骤
    \item 可以连续读写多个文件
    \item 可以执行“我打算做 A → 再做 B”
    \item 每一步通常需要你确认或可回滚
\end{itemize}

本质：IDE 内的“半自动助手”、人在回路（human-in-the-loop）

适合：小到中等规模改动、明确目标的 refactor、自动生成测试/文档

不适合：无人值守执行、大规模一次性不可逆改动、高频自动化任务

\subsection{Spaces}

一个“上下文容器”，不是 agent 本身。可以理解成给 Copilot / Agent 的一个“长期记忆 + 工作区”。

能装什么：
\begin{itemize}
    \item 当前 repo
    \item 特定子目录
    \item 文档、说明、约束
    \item 自定义背景信息（比如 coding style）
\end{itemize}

作用：让 Agent 在多轮对话中保持一致理解，避免每次都重新解释项目背景

适合：中大型项目、多天/多周的连续工作、需要稳定上下文的 agent 任务

不适合：一次性 quick question

\subsection{Spark（Preview）}

GitHub 正在试验的“AI 驱动的高层工作流”，目前还是 Preview。

目标：从“想法 / 需求”推导出代码结构、文件骨架、初始实现

能力形态：
\begin{itemize}
    \item 比 Agents 更高一层
    \item 偏“项目生成 / scaffold”
    \item 偏 product / workflow，而不是写单个函数
\end{itemize}

适合：新项目起步、PoC / demo、从零生成结构化代码

不适合：成熟项目的精细修改、需要严格一致性的底层代码、生产级自动化

\subsection{一句话总结}

New chat：随问随答
Agents：人在回路的多步助手
Spaces：给 AI 一个“长期脑子”
Spark：试验性的 AI 项目生成器

它们都不是命令行工具，而是围绕 IDE 设计的交互式能力。

} % end small
