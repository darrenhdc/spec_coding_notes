% chapter_11.tex - 工程连续性与 Context 机制
\small

\chapter{工程连续性与 Context 机制}

\section{工程连续性与会话连续性}

\subsection{/resume 的本质局限}

/resume 能恢复的是"对话状态"，而非"项目状态"。具体来说：

\begin{itemize}
  \item \textbf{能恢复的}：聊天上下文、未完成的指令、推理轨迹
  \item \textbf{不能恢复的}：repo 状态、分支状态、文档权威性
\end{itemize}

因此，/resume 是"聊天续杯"，不是"项目续命"。当需要"不中断、不丢失"时，正确的工程实践是：

\begin{itemize}
  \item WIP spec（docs/wip）
  \item ADR（docs/adr）
  \item 清晰的 commit
\end{itemize}

这些机制不依赖会话、不依赖模型、不依赖工具，是工程级的连续性保障。

\subsection{判断原则}

如果不敢只靠 /resume 交接给别人，那这段信息就不该只存在于 /resume 能恢复的地方。任何不能通过 git clone 恢复的 spec，都不是工程级 spec。

\subsection{Context 的真实机制}

所谓的"context 上下文"并非用户可查看、可管理、可审计的对象。云端不存在一个能访问的"上下文存储区"。隔天继续使用时，并非"恢复了旧的 context"，而是系统把"之前的对话文本"重新喂给模型，重新生成了一次新的上下文。

Context 在工程上指的是：当前一次模型推理时，被送入模型的那一整段输入 token 序列。它只在"这一轮推理"中存在。云端可能保留对话文本、会话 ID、元数据，但不会保留"上一次推理用过的 context"或"模型内部状态"。

LLM 是"无状态函数"，所有"状态感"都是通过不断重放文本模拟出来的：
\[
\text{LLM}(\text{context}) \rightarrow \text{output}
\]

上下文不是记忆，只是一次性的输入。隔天继续聊天，不是"恢复了过去"，而是"重新讲了一遍故事"。

\section{工程文档体系}

\subsection{文档分层与职责}

\begin{table}[h]
\centering
\small
\begin{tabular}{lccc}
\hline
\textbf{层级} & \textbf{工程级} & \textbf{依赖 Git} & \textbf{可恢复} \\
\hline
ADR & \checkmark & \checkmark & \checkmark \\
README & \checkmark & \checkmark & \checkmark \\
PRD & \checkmark & \checkmark & \checkmark \\
Plan/Design doc & \checkmark & \checkmark & \checkmark \\
WIP spec & \checkmark & \checkmark & \checkmark \\
CLAUDE.md & \checkmark (AI侧) & \checkmark & \checkmark \\
specify/droid specs & $\times$ & $\times$ & $\times$ \\
todo list (Copilot等) & $\times$ & $\times$ & $\times$ \\
/resume / /session & $\times$ & $\times$ & $\times$ \\
\hline
\end{tabular}
\caption{文档/机制的工程分层}
\end{table}

\subsection{PRD 与 Plan}

PRD（Product Requirements Document）定义产品目标、用户价值、功能范围、非功能性约束。工程地位为：工程级、长期有效、必须进 Git。PRD 决定"要做什么"，ADR 决定"为什么这样做"。

Plan/Design doc 定义技术方案、模块划分、里程碑、风险评估。工程地位低于 ADR/PRD，但可以修改、演进，必须可 review。WIP 是"讨论态"，Plan 是"阶段共识态"。

\subsection{完整文档优先级}

\begin{enumerate}
  \item ADR (docs/adr/*) - 不可违反
  \item PRD (docs/prd/*) - 定义产品目标与边界
  \item README.md - 项目事实与入口
  \item Plan/Design docs (docs/plan/*) - 实现路径与阶段策略
  \item WIP specs (docs/wip/*) - 讨论中内容
  \item CLAUDE.md - AI 行为与文档优先级声明
  \item Tool-local specs (.specify/, droid) - 一次性任务草稿
\end{enumerate}

\subsection{总原则}

\begin{itemize}
  \item 凡是定义"是什么 / 为什么 / 要做到什么程度"的 $\rightarrow$ 文档
  \item 凡是定义"现在这一次怎么做"的 $\rightarrow$ 工具
  \item 凡是不能被 git clone 恢复的 $\rightarrow$ 不算工程资产
\end{itemize}

PRD 定义目标，ADR 定义原则，Plan 定义路径；README 讲事实，WIP 承载讨论；CLAUDE.md 约束 AI，specify/todo/resume 只配当草稿。

\section{函数调用与 MCP Tools}

\subsection{函数调用的本质}

函数调用（function calling）是：AI 说"我要用某个函数，并给你参数"。

\[
\text{AI} \rightarrow \text{判断需要用工具} \rightarrow \text{输出结构化指令} \rightarrow \text{系统执行真实工具} \rightarrow \text{结果返回 AI}
\]

模型不执行代码，模型只做决定，执行的是系统。函数调用 = 给程序看的回答。

\subsection{MCP Tools}

MCP（Model Context Protocol）是一套"工具怎么描述给 AI 看"的标准。它规定了：工具名称、参数类型、返回值格式。MCP 把真实世界的工具包装成 AI 可以调用的函数。

MCP 并未赋予 AI 新能力。能力始终来自提供的工具。MCP 只是统一接口、减少胶水代码。

\subsection{MCP 与其他机制的关系}

\begin{table}[h]
\centering
\small
\begin{tabular}{lcc}
\hline
\textbf{机制} & \textbf{类型} & \textbf{功能} \\
\hline
/resume & 会话层 & 聊天续杯 \\
specify & 任务层 & 草稿 \\
todo list & UI 辅助 & 会话提示 \\
MCP tools & 真实世界操作 & 动真格 \\
Git/FS/DB & 工程事实来源 & 真理源 \\
\hline
\end{tabular}
\caption{各机制的定位}
\end{table}

MCP 是唯一"能动真格"的那一层。因为：明确 schema、明确参数、明确返回值、可以 version、可以 review。可以给工具写测试、做 ACL、做审计。

LLM 是大脑，函数调用是"举手说我要用哪个工具"，MCP 是"工具说明书的统一格式"，执行环境才是真正干活的手。

\subsection{实例分析}

用 Claude Code 在 macOS 的提醒事项 App 里创建新事项，是完整的函数调用案例：

\begin{enumerate}
  \item AI 判断：需要使用系统能力，而不是只回复文字
  \item AI 输出结构化指令（概念上）：
\begin{verbatim}
{
  "name": "create_reminder",
  "arguments": {
    "title": "开会",
    "date": "2026-01-07",
    "time": "08:00"
  }
}
\end{verbatim}
  \item Claude Code/插件将调用映射到 macOS Reminders API/AppleScript/Shortcuts
  \item 系统真的创建了提醒事项，执行结果再返回给 Claude
\end{enumerate}

当 AI 不再"告诉你怎么做"，而是"直接让系统替你做了"，并且是通过结构化指令完成的，那就是一次函数调用。

\section{Spec 历史版本查询}

\subsection{Spec 的三种载体层}

在 Droid 中，"能不能查询 spec 历史版本"取决于用的是哪一层的 spec 作为真理源：

\begin{verbatim}
┌─────────────────────────┐
│ ① Repo-level spec       │ ← Git / Markdown / YAML
│   (你能直接控制)        │
└─────────────────────────┘
            ▲
            │ sync / import
┌─────────────────────────┐
│ ② Project-level spec    │ ← Droid 内部 spec state
│   (system of record)    │
└─────────────────────────┘
            ▲
            │ derived / cached
┌─────────────────────────┐
│ ③ Session / View state  │ ← 当前执行上下文
│   (不可追溯)            │
└─────────────────────────┘
\end{verbatim}

\subsection{各层的历史可追溯性}

\textbf{情况 1：Spec 在 Repo（最稳、最推荐）}

完全不通过 Droid，直接用 Git：
\begin{verbatim}
git log spec/
git diff <commitA> <commitB> -- spec/
\end{verbatim}

或使用 PR 历史、blame、review 记录。这意味着历史 100\% 可追溯、审计级别、换 Droid/换账号/换厂商都不丢。这是 spec-coding 的"地基层"。

\textbf{情况 2：Spec 在 Droid 的 Project-level（系统态）}

正确的查询方式不依赖具体 UI 名称。应该看到至少一种：
\begin{itemize}
  \item Spec change timeline：spec 变更时间点、变更发起人
  \item Spec version/revision ID：S-12 rev.3 或类似 internal version hash
  \item Spec $\rightarrow$ Plan $\rightarrow$ Code 的关联链：这次改动基于哪个 spec 版本？
\end{itemize}

只要有这三者之一，说明 spec 被当作系统状态，而不是临时上下文。

\textbf{验证方法}：修改一条 spec（哪怕是标点），触发一次 agent 执行，回看执行记录。如果看到类似"Executed based on spec revision X"，说明 Droid 内部确实在版本化 spec。如果只有"当前 spec 内容"而没有时间线、revision、diff，无法回答"这段代码是基于哪一版 spec 生成的"，那 spec 实际上是"平台记忆"，不是工程资产。

\textbf{情况 3：Spec 只存在于 Session/View（最危险）}

只能看到当前 spec，刷新/换账号/重开项目后历史不可见，没有任何 diff/audit/rollback。这层 spec 本质上 $\approx$ prompt。一旦 spec 落在这一层，就谈不上连续性。

\subsection{判断标准}

有没有"历史 tab"不重要，能不能回答工程问题才重要。可以直接问系统/团队这三个问题：
\begin{enumerate}
  \item 这段代码基于哪一版 spec？
  \item spec 在上周和现在有什么差异？
  \item 如果我要回滚 spec，系统是否支持？
\end{enumerate}

都能回答 $\rightarrow$ spec 有历史；任意一个不能 $\rightarrow$ spec 只是当前态。

\subsection{最佳实践}

\textbf{最稳方案（强烈推荐）}：
\begin{itemize}
  \item Repo spec = 法律真理
  \item Droid spec = 执行状态
\end{itemize}

spec 的最终历史在 Git。Droid 读取/同步、执行、记录"用的是哪一版"。这样即使 Droid UI 改了、平台消失了，spec 历史仍然存在。

在 Droid 中，spec 历史是否可查询，不取决于有没有"历史按钮"，而取决于 spec 是否被当作"可版本化的系统状态"。最可靠的做法永远是：让 Git 保存历史，让 Droid 执行版本。

\section{"Spec Mode" 与真正的 Spec}

\subsection{概念混淆}

Droid 当前展示的 "Spec – research and plan only" 只是 agent 的执行模式（execution mode），而不是项目级规格说明（specification）。

\begin{table}[h]
\centering
\small
\begin{tabular}{lcc}
\hline
\textbf{属性} & \textbf{spec-coding 的 spec} & \textbf{Droid 的 Spec mode} \\
\hline
本质 & 项目级真理源 & Agent 行为限制 \\
可版本化 & \checkmark & $\times$ \\
有历史 diff & \checkmark & $\times$ \\
可被引用 & \checkmark & $\times$ \\
冲突时有否决权 & \checkmark & $\times$ \\
绑定 project & \checkmark & $\times$（只绑定当前 session） \\
\hline
\end{tabular}
\caption{两种 "Spec" 的本质区别}
\end{table}

\subsection{判断标准}

可以用这一句话来判断任何系统："这个 spec 如果我关掉 UI / 换一个 agent，它还能否继续约束行为？"

\begin{itemize}
  \item Droid 的 Spec mode：不能（只是当前会话模式）
  \item 真正的 spec：可以（项目级状态）
\end{itemize}

如果一个 spec 不能被版本化、不能被引用、不能在会话之外存活，那它在工程意义上就不是 spec。

\subsection{路径选择}

\textbf{路径 1（现实可控，推荐）：Repo-based Spec}

承认 Droid 当前并没有 project-level spec 实体暴露给你。把 spec 放回工程世界：/spec/*.md、CLAUDE.md。这样至少保证：
\begin{itemize}
  \item spec 不跟 session 走
  \item spec 不跟账号走
  \item spec 不被"Spec mode"混淆
\end{itemize}

\textbf{路径 2（等待/依赖平台）：Droid 原生 spec}

这条路的风险是：spec 是否存在不确定、spec 是否可导出不确定、spec 是否可审计不确定。从当前 UI 来看，这条路暂时不可验证。

\section{Repo-Native Spec 实践}

\subsection{Spec 历史的判断}

Repo-native spec 的历史有两层：

\textbf{第一层：文件级历史（最重要）}

使用"spec = append-only artifacts"模式，历史就是文件名时间顺序和 Git commit 历史。
\begin{verbatim}
ls specs/ | sort
git log -- specs/
\end{verbatim}

每一个 .md 文件 = 一个不可变 spec snapshot。

\textbf{第二层：语义历史（哪一个在"生效"）}

Repo 并不会自动告诉你哪个 spec 是 current。原因很简单：spec 是决策，不是状态变量。

\subsection{Current Spec 的判断}

\textbf{重要规则}：current spec = 最近一次被"明确采用"的 spec，而不是文件名最新、Droid 标 latest、UI 显示。

\textbf{三种合法的 current spec 判定方式}：

\begin{enumerate}
  \item \textbf{有指针文件（推荐）}：
\begin{verbatim}
specs/CURRENT.md
内容：
# Current Spec
As of 2025-12-31, the authoritative spec is:
- 2025-12-31-approve-max_approve_usdc.md
All implementations and plans must comply with this spec.
\end{verbatim}
  这是最清晰、最工程化的做法。

  \item \textbf{被代码/plan 显式引用}：
\begin{verbatim}
This implementation follows spec:
2025-12-31-approve-max_approve_usdc.md
\end{verbatim}
  spec 通过"引用"生效。

  \item \textbf{被 supersede（覆盖关系）}：
\begin{verbatim}
Supersedes:
- 2025-12-31-approve-buffer-unlimited-500-usdc.md
\end{verbatim}
  语义上自动成为 current。
\end{enumerate}

\subsection{工程治理}

已经解决了"spec 在哪里、有没有历史"的问题，剩下的问题是：spec 何时、如何、由谁被声明为 current。这已经不是工具问题，而是工程治理问题。

可以：
\begin{itemize}
  \item 重构 specs 目录（append-only + supersede 规则）
  \item 设计 spec lifecycle 规范（draft $\rightarrow$ adopted $\rightarrow$ superseded）
  \item 设计"agent 必须引用 CURRENT.md 才能执行"的硬约束
\end{itemize}

\section{Copilot Todo List 的本质}

\subsection{Todo List 的真实属性}

Copilot 的 todo list 本质是：编辑器插件维护的 UI 状态 / 任务提示，而不是：
\begin{itemize}
  \item Git 中的文件
  \item 云端工程文档
  \item 项目级 spec
\end{itemize}

Copilot 的 todo list $\neq$ LLM 的"长期记忆" $\neq$ /resume 的恢复对象。

它更像是 VS Code 插件在当前 workspace、当前 session 或插件本地缓存里维护的一份状态。

\subsection{Todo List 能否通过 /resume 恢复？}

\textbf{不能保证，通常也不应该指望。}

如果 todo 是你们在聊天中明确列出来的，/resume 可能"接着聊下去"；但如果 todo 是 Copilot UI 自动生成的、插件状态、没有写进 repo / 文档，那它和 /resume 没有工程级关系。

\subsection{AI 是否有"云端文档仓库"？}

在目前这些工具里（Claude / Copilot / droid），没有一个对用户开放、可审计的"AI 项目文档仓库"。如果有，那一定是明确告诉你存在哪里、怎么导出、怎么版本控制。否则都不是工程级存储。

\subsection{可审计性判断}

以后你看到任何"AI 帮你记住了 X"，问一句："我现在能不能把它导出、commit、review？"

\begin{itemize}
  \item ✅ 能 $\to$ 工程资产
  \item ❌ 不能 $\to$ 会话幻觉
\end{itemize}

\section{工具选择：AI Agent 与古法 Vibe}

\subsection{适用场景分析}

在 transformers 这种"接口经常变、体量巨大、语义靠源码而不是注释"的库里，用 AI agent/vibe coding 的"性价比和安全性"反而低于古法手写 + 文档 + grep。

\begin{table}[h]
\centering
\small
\begin{tabular}{lcc}
\hline
\textbf{维度} & \textbf{业务代码} & \textbf{模型/transformers} \\
\hline
API 稳定性 & 高 & 极低 \\
文档完整度 & 中 & 相对最好 \\
行为是否直观 & 是 & 否 \\
错误是否显性 & 报错 & silent \\
AI 可靠性 & 高 & 低 \\
\hline
\end{tabular}
\caption{不同场景下的 AI 可靠性}
\end{table}

\subsection{模型侧工作的特点}

模型/底层库/training/inference glue 的代码特点是：
\begin{itemize}
  \item 接口是软约定（不总写清楚）
  \item 行为靠实现细节
  \item 一点点错 = silent bug/数值错/性能灾难
\end{itemize}

这是 AI agent 最不擅长的区域之一。

Transformers 库的特点：
\begin{itemize}
  \item API 多、历史包袱重、同名函数多版本、文档永远落后于实现
  \item 接口不稳定、breaking change 频繁
  \item PR/release/main 分支行为不一致
\end{itemize}

AI agent 的知识几乎必然是"滞后 + 混合态"的。即使能查库，AI agent 不会像人一样：rg class\_name、跳进源码、看 call graph、追 commit diff。即使能，也做得慢、不可靠、容易 hallucinate。

\subsection{文档的优势}

在模型库场景下，文档可能比 AI 好使，因为：
\begin{itemize}
  \item 文档是当前版本锁定的
  \item 文档是作者意图
  \item 文档会写 deprecated/caveat
\end{itemize}

而 AI 会混合多个版本、不知道哪些已废弃、很容易"合理胡说"。

\subsection{古法 Vibe 的真实含义}

不是不用工具，而是用对工具：
\begin{itemize}
  \item IDE + LSP
  \item grep/ripgrep
  \item 看源码
  \item 看 commit history
  \item 跑最小复现脚本
  \item 手写改动
\end{itemize}

这是"底层工程的 vibe"。

\subsection{适用域不同}

Spec-coding + agent + 自动化 + 多文件协作，与单点接口 + 高频变更 + 模型行为一致性，面对的是两个完全不同的工程地形。在接口频繁变化、行为靠源码定义、错误不显性的模型库里，AI agent 的不确定性会被放大。经验工程师选择古法开发，不是保守，而是风控。

在外围 glue/实验代码/pipeline 生成上，AI 仍然有价值。问题不在工具本身，而在选择合适的工具用于合适的场景。

\vspace{1em}
\normalsize
