% chapter_02.tex - Spec Coding 文档与工具
\small

\chapter{Spec Coding 文档与工具}

\section{Claude Code 文档体系}

\subsection{PRD / plan / CLAUDE.md 的层级关系}

\textbf{PRD.md}（产品需求文档）：
\begin{itemize}
  \item 定义"做什么"和"为什么做"
  \item 作为参考上下文加载，非 system prompt
  \item 描述产品目标、用户需求、功能范围
\end{itemize}

\textbf{plan.md}（实施计划）：
\begin{itemize}
  \item 定义"怎么做"的技术方案
  \item 同样作为参考材料
  \item 包含架构设计、技术选型、实施步骤
\end{itemize}

\textbf{CLAUDE.md}（项目约束规则）：
\begin{itemize}
  \item 优先级最高，接近"会话级 system context"
  \item 定义不可违反的行为约束
  \item 包含编码规范、安全要求、项目特定规则
\end{itemize}

\subsection{文档遗忘问题与应对策略}

Claude Code 的三文件体系存在以下局限：

\begin{enumerate}
  \item \textbf{跨会话遗忘}：关闭后重新打开，需要重新加载
  \item \textbf{上下文溢出}：新对话会挤压旧信息
  \item \textbf{实现 drift}：agent 以当前代码为事实源，而非文档
\end{enumerate}

\textbf{应对策略}：
\begin{enumerate}
  \item \textbf{锚点最小化}：只保留 5-10 条必须不变的硬约束
  \item \textbf{提升到 CLAUDE.md}：绝对不能违反的行为规则
  \item \textbf{Re-anchor Prompt}：关键修改前强制重新阅读文档
  \item \textbf{阶段化 plan}：只保留当前阶段的计划
\end{enumerate}

\section{Drift 与 Hallucination 机制}

\subsection{Drift 的本质}

Drift 是 LLM 在长期交互中逐渐偏离初始意图的现象：

\begin{itemize}
  \item \textbf{语义漂移}：对同一概念的理解逐渐变化
  \item \textbf{约束松弛}：初期遵守的规则逐渐被忽略
  \item \textbf{上下文污染}：早期决策被后期信息覆盖
\end{itemize}

\subsection{Drift 产生的机制}

\begin{enumerate}
  \item \textbf{上下文窗口有限}：新信息挤压旧信息
  \item \textbf{概率性生成}：每次生成都是重新采样，存在随机性
  \item \textbf{缺乏显式锚点}：没有强制性的真值源
\end{enumerate}

\subsection{防止 Drift 的方法}

\begin{enumerate}
  \item \textbf{显式锚点}：用 CLAUDE.md 定义不可违反的约束
  \item \textbf{定期 Re-anchor}：在关键节点重新加载核心文档
  \item \textbf{版本化 spec}：让决策有明确的"真相时刻"
  \item \textbf{分离对话与执行}：决策阶段和执行阶段分开
\end{enumerate}

\section{Droid 系统架构}

\subsection{Droid 与 Claude Code 的根本差异}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\hline
\textbf{文件} & \textbf{Claude Code} & \textbf{Droid} \\
\hline
PRD.md & 参考材料 & 系统真理（Authoritative State） \\
plan.md & 设计说明 & 可执行结构（Execution Graph） \\
CLAUDE.md & 说明文件 & Agent 宪法（Policy Layer） \\
\hline
\end{tabular}
\end{table}

\subsection{Droid 的核心假设}

Droid 的设计假设是"agent 默认不可信"：

\begin{itemize}
  \item spec 拥有系统级否决权
  \item plan 是执行约束，而非建议
  \item agent 行为规则是系统的一部分，不可随意覆盖
\end{itemize}

Claude Code 的三文件体系是"把工程纪律显式写出来给 AI 看"，Droid 则是"把纪律写进系统本身"。

\subsection{Drift 防护机制}

Droid 通过以下机制防止 drift：

\begin{enumerate}
  \item \textbf{System-level enforcement}：spec 在系统层面强制执行
  \item \textbf{Explicit state tracking}：维护显式的 spec state
  \item \textbf{Reference obligation}：任何实现必须引用 spec 条目
  \item \textbf{Conflict detection}：显式检测和处理冲突
\end{enumerate}

\section{spec-kit 工具链}

\subsection{spec-kit 的本质}

spec-kit 不是"让 Claude 更聪明"，而是把靠自觉维护的 PRD/plan/CLAUDE.md 流程，变成：

\begin{itemize}
  \item \textbf{可执行}：spec 可被机器解析和验证
  \item \textbf{可审计}：每个改动都能追溯到 spec
  \item \textbf{可持续}：建立长期的工程记忆
\end{itemize}

\subsection{spec-kit 与手写文档的对比}

\textbf{spec-kit + Claude Code}：
\begin{itemize}
  \item 强制 artifact 链条（不能跳步）
  \item 明确"哪一步可以问不确定问题"
  \item spec/plan/tasks 都是机器可解析的
\end{itemize}

\textbf{手写文档}：
\begin{itemize}
  \item 完全可控
  \item 高度贴合个人习惯
  \item 容易出现 drift、不一致
\end{itemize}

\subsection{spec-kit 实战流程}

\begin{enumerate}
  \item \texttt{specify init . --ai claude}：初始化项目
  \item \texttt{/speckit.constitution}：写项目宪法
  \item \texttt{/speckit.specify}：写功能 spec
  \item \texttt{/speckit.plan}：生成技术方案
  \item \texttt{/speckit.tasks}：生成任务拆分
  \item \texttt{/speckit.implement}：让 Claude 写代码
\end{enumerate}

\subsection{与 Vibe Coding 的交互差异}

\textbf{旧范式（Vibe Coding）}：对话 = 即执行，决策和实现混在一起

\textbf{新范式（Spec-Driven）}：
\begin{itemize}
  \item 对话阶段：讨论 spec（what/why）和 plan（how），不写代码
  \item 执行阶段：\texttt{/speckit.implement} 按计划执行
  \item 角色：从"即时批准者"变为"规范制定者"
\end{itemize}

\subsection{Commit 与 Merge 时机}

\textbf{关键原则}：
\begin{itemize}
  \item \texttt{/speckit.implement} 不会自动 commit
  \item implement 和 merge 不是原子操作
  \item merge 永远是人类的权力边界
\end{itemize}

\textbf{推荐节奏}：
\begin{enumerate}
  \item spec/plan/tasks 完成后 commit
  \item implement 执行
  \item review（git diff / PR）
  \item 满意后 commit implementation
  \item merge（squash 推荐）
\end{enumerate}

\section{Claude Skills 的本质}

\subsection{Skills 的本质}

所谓的"Claude skills"本质是：
\begin{itemize}
  \item 一组固定的 prompt 模板
  \item 一些 if/when/condition
  \item 一些行为约束
  \item 一点"人类写的经验总结"
\end{itemize}

claude.md 的作用是：在每次对话/任务时，把这些规则"注入上下文"。

\subsection{省 Token 的真相}

Skills 省 token 的前提是：你原本就打算反复注入同一堆指令。

但在 spec-coding 里，你写的是明确 spec、明确任务，Claude 不需要靠"skills 猜"。spec-coding 消耗 token 是因为你在"外包思考"，而不是因为它低效。

\subsection{Skills 的不可靠性}

\begin{enumerate}
  \item \textbf{没有稳定接口}：模型一升级，行为就可能变化
  \item \textbf{经验叠加}：是"我觉得这样好"，不是明确契约
  \item \textbf{不可迁移}：博主的项目背景与你的完全不同
  \item \textbf{营销载体}：制造信息差、暗示稀缺、承诺捷径
\end{enumerate}

\subsection{工程判断}

真正强的 LLM 使用者，往往 skills 很少，spec 很清楚。因为模型最擅长明确任务、明确约束，最不擅长模糊经验、玄学规则。

\textbf{判断准则}："如果模型换了、上下文变了、团队换人了，这套方法还成立吗？"
\begin{itemize}
  \item 成立 $\to$ 工程方法
  \item 不成立 $\to$ marketing/hack
\end{itemize}

\section{文档优先级与 CLAUDE.md}

\subsection{三文件的角色}

\textbf{ADR}：项目的「宪法条款」。记录：为什么做了某个不可逆决定。面向：未来的工程师（包括你自己）。特点：稳定、可追溯、不频繁修改。ADR 是「事实之上的理由」，不是操作说明。

\textbf{README}：项目的「说明书」。记录：项目是什么、如何运行/使用。面向：新人、用户、外部贡献者。特点：相对稳定、高层概述。README 不解释复杂历史决策。

\textbf{CLAUDE.md}：AI 的「工作指令书」。记录：spec 优先级、禁止事项、代码风格、agent 行为边界。面向：AI（Claude/droid/未来工具）。特点：工具相关、可变、行为导向。CLAUDE.md 是「怎么干活」，不是「为什么这么设计」。

\subsection{优先级在 CLAUDE.md 中定义}

五个文档的优先级顺序，最合适、最有效、最不混乱的定义位置就是 CLAUDE.md。因为：它面向 AI、它约束行为、它不承载工程事实本身。

推荐写法：
\begin{verbatim}
## Document precedence rules

When multiple documents provide guidance, follow this order:

1. Architecture Decision Records (docs/adr/*)
   - Highest authority
   - Must not be violated

2. README.md
   - Defines project-level facts and usage

3. WIP specs / design docs (docs/wip/*)
   - Temporary and collaborative
   - Must not contradict ADRs or README

4. CLAUDE.md
   - AI behavior and workflow rules
   - Cannot override any of the above

5. Tool-local specs (.specify/, droid specs, .cursor)
   - Task-local working memory
   - Must never override committed documents

If any conflict is detected, stop and ask for clarification.
\end{verbatim}

CLAUDE.md 里写「优先级」，并不是说 CLAUDE.md 比 README 或 ADR 更高。恰恰相反：CLAUDE.md 是在自我约束，它是在说：「我（AI）承认我在这个体系里的位置。」

\vspace{1em}
\normalsize
