% chapter_16.tex
% Git 工作流与 Spec Coding 实践

\small

\section*{Squash：选择性公开历史}

\subsection*{定义与直觉}

Squash = 把多个 commit"压扁"为一个 commit。将 commit 链从 A-B-C-D-E 压缩为单个 commit X，历史被"整理过"，只留下一个"对外可读"的结果。

\subsection*{解决的问题}

不 squash 时，main 分支历史充满"fix typo"、"wip"等噪音。Squash 让 main 只保留"做了什么"而非"怎么折腾的"，是对主线历史可读性的优化手段。

\subsection*{与 spec-driven 的关系}

在 spec-driven 中，squash 非常常见且推荐。因为 spec/plan 已记录过程，main 更适合只保留 spec 定义和最终实现。健康的结果是 main 中每个 commit 对应一个完整的 feature 意图。

\subsection*{重要澄清}

squash ≠ 删除历史。原 commit 仍保留在 feat 分支和 reflog 中，只是不进入 main。这是"选择性公开历史"，而非抹除历史。

\subsection*{何时不用 squash}

release/hotfix 分支需要精确 bisect 的历史时，每个 commit 都应是稳定点。

\subsection*{判断口诀}

main 要不要看懂"你怎么一步步写的"？不需要 → squash；需要 → 不 squash。

\subsection*{spec-driven 最佳实践}

在 feat/* 分支上随意 squash；PR merge 时 squash 整个 feature；不在 main 上做 rebase/squash。让 feature 内部历史自由，main 历史干净。

\subsection*{本质}

squash 的本质：把"开发过程"留在 feature 分支，把"工程结果"放进 main。

\par\noindent\hrule\par

\section*{Squash 的作用范围}

\subsection*{常见误解}

很多人以为 squash 只能压缩顶部一段 commit 链。这是错误印象。

\subsection*{真实能力}

Git 的 squash 本质是合并多个 commit 的 diff。前提是：这些 commit 在同一条线性历史上；能明确指定"哪些 commit 参与合并"。Git 不要求它们在最顶部，但必须连续、可重写。

\subsection*{为何造成误解}

99\% 的工具只暴露了"压缩顶部"的用法：PR 的"Squash and merge"默认压缩从分支起点到 HEAD；git rebase -i HEAD~5 只显示最近的 commit。

\subsection*{实际能力}

你可以用 \texttt{git rebase -i <某个更早的 commit>} squash 任何一段连续提交，包括中间段或不包含 HEAD 的段。但这是历史重写，只能在自己的 feature 分支上进行。

\subsection*{工程实践}

我们几乎"只在顶部 squash"是工程纪律，非技术限制：避免影响别人；PR 语义天然是"一段顶部历史"；认知负担最低。

\subsection*{精确表述}

Squash 的限制不是"必须在顶部"，而是"必须是连续、可重写的一段历史"。

\par\noindent\hrule\par

\section*{Merge 后是否开新分支}

\subsection*{结论}

feat 分支一旦 merge 到 main，其"使命"就结束。继续 spec-coding 新内容时，应从 main 再开新的 feat 分支。

\subsection*{原因}

\textbf{原因 1：merge = 生命周期结束。} merge 声明"这个 feature 已完成并被主线接受"。继续在同一分支写新 spec 会让 PR、review、回滚边界模糊。

\textbf{原因 2：PR/spec 语义崩坏。} 已 merge 的 feat/xxx 上继续写新的 spec.md/tasks.md，会导致"这个分支代表哪个 feature"、"PR review 的 scope 是什么"等问题。

\textbf{原因 3：spec-driven 强依赖边界清晰。} spec-driven 中：一个 feature → 一组 spec/plan/tasks → 一次 implement → 一次 merge，形成闭环。

\subsection*{标准流程}

\begin{verbatim}
# 1. 旧 feature 已 merge
git checkout main
git pull

# 2. 开新 feature
git checkout -b feat/user-auth

# 3. 新的 spec coding
.specify/specs/002-user-auth/
\end{verbatim}

\subsection*{分支命名}

名称表达意图而非工具生成：feat2、feat/user-auth、feature/checkout、task/123-user-auth 均可。spec-kit 完全不关心 Git 分支名，只读取当前分支并写 spec 到 \texttt{.specify/specs/<some-id>/}。

\subsection*{例外情况}

\textbf{例外 1：} merge 后立刻发现小 bug/typo。可用 \texttt{git checkout -b fix/todo-cli-typo} 或直接在 main hotfix（小项目/solo），但这已是维护而非 spec-coding。

\textbf{例外 2：} spec 尚未 merge，只是第一次 implement。若 spec/plan 已写但代码未 merge/PR 还在 review，不用开新分支。同一 feature 内可反复 spec → implement → 调整。只有真正 merge 后生命周期才结束。

\subsection*{判断口诀}

"我要做的这件事，在 PR 描述里能不能用一句话和上一次区分开？"能 → 新分支；不能 → 同一 feature。

\subsection*{spec-driven 对应关系}

spec 是 feature 的定义；merge 是 feature 的完成声明。所以：新 spec = 新 feature = 新 branch。这是 1:1:1 对应关系。

\par\noindent\hrule\par

\section*{分支命名与 spec-kit}

\subsection*{分支名能否重复}

可以"再次使用同一个名字"，但不能"在同一时间重复存在"。Git 规则：同一仓库、同一时间点不能有两个同名分支。但旧分支删除后可再创建同名分支，Git 不会记得"之前用过这个名字"。

\subsection*{工程实践}

通常不推荐复用完全相同的 feature 分支名，原因是 PR 历史混淆、日志不好读、人类记忆差。推荐做法：feat/todo-cli、feat/todo-cli-v2、feat/user-auth、feat/checkout-flow 或 feat/123-todo-cli。名字表达"意图"而非"工具生成"。

\subsection*{spec-kit 的角色}

spec-kit 完全不关心 Git 分支名。它只读取当前 Git 分支，把 spec 写到 \texttt{.specify/specs/<some-id>/}，用 <some-id> 作为 feature 内部标识。这个 id 不是 Git 分支名，不要求一一对应，通常是递增数字 + slug。

\subsection*{两套命名系统}

Git 分支名：人类协作用，不与 spec 目录强绑定。.specify/specs/<id>：spec 组织用。两者关系是弱关联、非强绑定、靠人理解。

\subsection*{安全心法}

Git 分支名是"临时工作名"；spec 目录名是"长期设计档案号"。一个可以删，一个不该轻易删。

\par\noindent\hrule\par

\section*{Merge 历史形态}

\subsection*{毛毛虫效应}

使用普通 merge（非 squash）时，merge 后通常不删除原 commit，整个历史看起来像一条"毛毛虫/树枝状"。这不是 Git 的必然结果，而是 merge 策略的选择。

\subsection*{普通 merge}

执行 \texttt{git merge feat} 生成 merge commit。所有原 commit 保留，历史非线性。用 \texttt{git log --graph} 看像长着小脚的毛毛虫。Git 原则：历史默认不可丢失，删的是"指针"不是 commit。commit 只要被 merge 就永远存在于 main 历史。

\subsection*{Squash merge}

多个 commit 的 diff 合并为一个新 commit X。原 commit 不进入 main，历史重新变直（linear history）。没有毛毛虫，像蚯蚓。

\subsection*{Rebase + merge}

merge 前做 \texttt{git rebase main} 然后 fast-forward merge。历史线性，但 commit hash 已被改写。

\subsection*{选择标准}

都不是好坏问题，是选择。保留毛毛虫（普通 merge）优点：保留完整开发过程、可精确 bisect，适合大型团队、release/hotfix 流程。消灭毛毛虫（squash/rebase）优点：main 历史干净、每个 commit 是完整语义单元，适合 spec-driven、PR-based workflow、feature=intent。

spec-driven 通常选 squash，因为 spec/plan 已记录过程，main 更像"产品演进日志"而非"开发录像"。

\subsection*{判断口诀}

你希望 main 像"故事书"还是"监控录像"？故事书 → squash；监控录像 → 普通 merge。

\par\noindent\hrule\par

\section*{Merge 策略选择}

\subsection*{常见度排序}

在现代 PR-based workflow 里：Squash merge 最常见；普通 merge（merge commit）次常见；Rebase merge（直接在 main 上 rebase）最少。尤其在 GitHub/GitLab + PR + spec-driven 场景。

\subsection*{Squash 为主流的原因}

\textbf{原因 1：PR 语义 = "一个意图"。} PR 声明"我完成了一件事，请把它合进去"，squash merge 正好是"把这一件事变成 main 上的一个 commit"，两者 1:1 对齐。

\textbf{原因 2：现代 PR commit 粒度不干净。} PR 里经常是"fix typo、address review、oops forgot test、tweak"。不 squash 会让 main 被噪音 commit 淹没。

\textbf{原因 3：spec-driven 已保存过程。} spec-driven 中过程 = spec/plan/tasks，main 更像"结果日志"，squash 非常自然。

\subsection*{普通 merge 的适用场景}

普通 merge 仍有价值，更适合：Linux kernel、编译器/基础设施项目、强依赖 git bisect、每个 commit 都被要求是"可运行状态"。这些项目里 commit 本身就是设计单元。

\subsection*{Rebase 为何最少}

rebase = 历史重写 + 高认知成本。在 main 上 rebase 的问题：谁在什么时候改写了历史？多人同时操作易出事故；PR review 时 hash 会变。所以大多数团队禁止在 main 上 rebase，rebase 只允许在 feature 分支内。

\subsection*{精确对比}

\begin{tabular}{|l|l|l|}
\hline
策略 & feature 内 commit & main 上 commit \\
\hline
普通 merge & ✅ 原样保留 & ✅ 原样保留 \\
squash merge & ✅ 保留在 feat & ❌ 不进入 main \\
rebase + FF & ✅ 改写后保留 & ✅ 线性进入 main \\
\hline
\end{tabular}

\subsection*{spec-driven 推荐}

squash 满足 4 点：main 历史可读、feature 内部自由、PR review 聚焦、回滚语义清晰。而 spec/plan 本身就是"过程记录"。

\subsection*{建议}

如果不确定用哪种，默认用 squash merge。等你明确知道"为什么不用 squash"时再换。

\par\noindent\hrule\par

\section*{Rebase 理解}

\subsection*{常见误解}

很多人认为 rebase = stash + pull + 同步代码。这个理解抓住了"体感层"但机制层有误。

\subsection*{纠正}

\textbf{❌ rebase ≠ stash + pull。} git rebase 只作用于已 commit 的修改；git stash 作用于未 commit 的工作区修改。它们解决不同层次的问题。

\textbf{❌ rebase 不是"同步代码"，而是"重写历史"。} 结果看起来像同步，本质不是同步。

\subsection*{真正本质}

Git rebase = 把"我这一串 commit"从"旧的 base"重新接到"新的 base"上。

\subsection*{图形示例}

原始状态：
\begin{verbatim}
main:  A ── B ── C
               \
feat:            D ── E   (你的提交)
\end{verbatim}

执行 \texttt{git rebase main}，Git 会暂存 D、E 的 diff，把 feat 回退到 C，把 D、E 的 diff 重新应用：

\begin{verbatim}
main:  A ── B ── C
                       \
feat:                    D' ── E'
\end{verbatim}

内容一样，commit hash 全变，历史变成线性。

\subsection*{stash 的角色}

stash 是"可选的前置操作"，不是 rebase 的一部分。工作区干净 → 直接 rebase；有未提交修改 → Git 拒绝。常见流程：

\begin{verbatim}
git stash
git rebase main
git stash pop
\end{verbatim}

这是为了让 rebase 能跑，不是 rebase 的定义。

\subsection*{pull 的拆解}

\texttt{git pull = git fetch + git merge}。所以 \texttt{git pull} 其实是 merge 不是 rebase。正确的"rebase 同步"姿势是：

\begin{verbatim}
git fetch origin
git rebase origin/main
\end{verbatim}

或 \texttt{git pull --rebase}。

\subsection*{工程级正确表述}

"我在 feature 分支上，通过 rebase 把自己的提交重新基于最新的 main 应用一遍，让历史看起来像是从最新 main 开始开发的。"

\subsection*{何时 rebase}

✅ 只在自的 feature 分支上；✅ 在提交还没被别人依赖时；❌ 不要在 main/已共享分支上 rebase。

\subsection*{spec-driven 对齐}

spec-driven 里，rebase ✅ 常用于：在 PR 前整理历史、保持 feature 分支线性；rebase ❌ 不用于：自动 merge、替代 review。

\subsection*{本质}

rebase 的体感像"同步代码"，但本质是"重写你这段提交的历史位置"；stash 只是为了让它能发生，而非 rebase 本身。
